# [TIL] 2024.11.07📒

### [Wanted 프리온보딩 BE 챌린지]

* 랜덤클래스
  * 랜덤클래스는 싱글톤으로 되어있기 때문에, 스레드 경합상황이 발생하여 동시 요청에 성능상에 이슈가 생길 수 있다.
  * 그렇다면 더 나은 방법은?
    * ThreadLocalRandom
      * 장점
        * 스레드 독립성
          > ThreadLocalRandom은 각 스레드에 독립적인 시드를 사용함    
          > 이를 통해 여러 스레드가 동시에 난수를 생성하더라도 동일한 난수 생성기에 접근하지 않기 때문에 경쟁이 발생하지 않으며, 성능이 더 높음
        * 성능 향상
          > 일반적인 Random클래스는 스레드 간에 공유되기 때문에, 멀티스레드 환경에서 사용 시 내부적으로 락이 필요하여 성능저하가 발생할 수 있음     
          > ThreadLocalRandom은 슬드마다 난수 생성기가 따로 있으므로 락이 필요하지 않아 성능이 향상됨
      * 사용시 유의 점
        * ThreadLocalRandom은 시드를 설정하는 방법을 지원하지 않음
        * 시드 설정이 필요한 경우 일반 Random을 사용해야 함

* Request 처리 프로세스🔧
  * HandlerAdapter가 Handler(= Controller)로 요청을 위임

* ArgumentResolver 상세 프로세스🔧
  1. Handler를 호풀하여 파라미터 타입 정보를 받는다
  2. ArgumentResolver를 호출해서 Controller의 파라미터 객체 생성을 요청함
  3. Parameter를 가공할 때 HTTPMessageConverter를 사용하여 변환

* @ResponseBody
  * @ResponseBody는 메서드의 반환 값을 JSON 또는 XML 등의 형태로 직렬화하여 HTTP 응답 본문에 포함하도록 함.
  * 이때 Spring은 기본적으로 HttpMessageConverter를 사용하여 객체를 직렬화
  * @NoArgsConstructor가 없더라도 @JsonCreator 등을 활용하여 특정 생성자를 사용할 수 있음
  * @NoArgsArgument, @Setter, @AllArgsArgument를 굳이 사용할 필요 없음

* 스트림은 어떻게 최적화를 할까?
  1. 지연 연산
     * 스트림의 중간연산은 즉시 실행되지 않고, 최종 연산이 호출될 때까지 대기하는 지연연산을 사용함
     * 이 방식은 필요하지 않은 연산을 피하거나, 전체 데이터를 한 번에 처리하지 않고 효율적으로 필요한 데이터만 처리하도록 최적화 함
     * ex) .filter()와 .map() 같은 중간 연산을 거친 후 .findFirst() 같은 최종 연산을 사용할 경우, 필요한 데이터가 발견되면 
           나머지 요소는 더 이상 처리하지 않게 되어 성능이 향상됩니다.
  2. 내부 반복
     * 스트림은 내부 반복 방식을 사용하여 데이터 처리를 함
     * 일반적인 for 또는 while문을 사용하는 외부 반복과 달리, 반복 처리를 스트림 내부에서 수행하여 최적화된 반복이 가능함
     * 내부 반복을 사용하면 Java가 병렬 처리와 같은 최적화 기법을 쉽게 적용할 수 있음
  3. 병렬 처리
     * 스트림 API는 데이터를 쉽게 병렬 처리 할 수 있는 기능을 제공함
     * parallelStream()을 사용하면 데이터를 여러 CPU 코어에 분배하여 병렬로 처리할 수 있고, 이로 인해 대량의 데이터를 처리할 때 성능을 크게 개선할 수 있음
  4. 최적화된 메모리 관리
     * 스트림은 데이터를 한 번에 모두 메모리에 로드하지 않고, 필요할 때만 하나씩 처리하는 방식으로 메모리를 효율적으로 관리함
     * 이를 일관처리(pipeline)방식으로 수행하며, 이 과정에서 메모리 사용량을 줄여 대량 데이터 처리에서도 효율적으로 동작함
  5. 함수형 프로그래밍을 통한 코드 간결화
     * 스트림 API는 함수형 스타일로 작성되기 때문에 코드가 간결해지고, 반복 로직이 명확해져 최적화 기회를 찾기 쉬움
     * 불필요한 조건문과 반복문을 줄여 성능 향상에 도움이 될 수 있음. 
