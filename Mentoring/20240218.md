# 20240218(13회차) 멘토링 내용 정리📒

### JPA의 FetchType.EAGER / LAZY
* JPA의 Fetch란?
  * Entity를 조회할 때 그 Entity와 연관관계가 있는 다른 Entity의 정보를 어느 시점에 가지고 올 지 결정하는 것
  * 즉 엔티티 관계를 로딩하는 방식을 정의하는 열거형
* Fetch의 타입
  * **LAZY(지연 로딩)**
    * 게으른 이란 뜻을 가지며, 사전 의미와 같이 실제로 엔티티 조회시에 바로 가져오지 않고, 연관 관계에 있는 엔티티를 참조할 때    
      로딩함
    * 이 방식은 필요할 때만 데이터를 로딩하기 때문에 성능 최적화에 도움이 될 수 있지만, 연관된 엔티티에 접근하는 시점에서     
      추가적인 쿼리가 발생할 수 있으며, 이는 N+1문제와 같은 성능 이슈를 야기할 수 있다.
  * **EAGER(즉시 로딩)**
    * LAZY와는 반대로 엔티티 조회시에 바로 연관관계에 있는 모든 Entity를 가지고 온다.
    * 이 방식은 연관된 데이터가 항상 사용되는 경우 유용하나, 필요하지 않는 데이터까지 불러와 성능에 부정적인 영향을 줄 수 있다.

### JPA N+1문제
* **N+1 문제란?**
  * 연관관계에 있는 데이터를 조회할 때 객체를 가져오기 위한 쿼리(1번의 쿼리) + 해당 객체와 관련이 있는 객체를 가져오기 위한 쿼리(N번의 쿼리) 가 수행 됨    
  * 이 문제는 데이터가 가져와야하는 1번의 쿼리가 많아질 수록 성능에 문제를 야기함
* 해결 방법
  * **조인 사용**
    * 연관된 객체를 로딩할 때 조인을 사용하여 필요한 모든 데이터를 단일 쿼리로 가져옴
    * JPA에서는 fetch join을 이용하여 구현 가능
      ```
      // EntityManager 설정
      EntityManager em = ...;
      
      // Fetch Join을 사용하여 User와 연관된 Order 객체를 함께 로딩하는 쿼리
      TypedQuery<User> query = em.createQuery(
          "SELECT u FROM User u JOIN FETCH u.orders", User.class);
      List<User> users = query.getResultList();
      ```
  * **배치 사이즈 설정**
    * 지연 로딩을 사용할 때, 한 번에 로딩할 연관 객체의 수를 지정하여 N+1 쿼리 대신 적은 수의 쿼리로 필요한 데이터를 로딩할 수 있음
      ```
      @Entity
      class User {
          @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
          @BatchSize(size = 10) // 한 번에 로딩할 Order 객체의 수를 10으로 설정
          private Set<Order> orders;
      }
      ```
  * **서브 셀렉트 사용**
    * 서브셀렉트 전략을 사용하여 관련 객체를 로딩할 때 필요한 모든 데이터를 가져오는 서브쿼리를 살행함.
      ```
      @Entity
      class User {
          @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
          @Fetch(FetchMode.SUBSELECT)
          private List<Order> orders;
      // 첫 번째 User의 orders에 접근할 때, 해당 User뿐만 아니라 로딩된 모든 User의 orders도 함께 로딩.
      }
      ```

### 데드 레터(Dead Letter)
* **데드 레터란?**
  * 메시징 시스템에서 처리할 수 없는 메세지를 위한 특별한 처리 방식
  * 메시징 시스템에서는 메시지를 수신자에게 전달하려고 시도하지만, 여러가지 이유로 인해 메시지를 성공적으로 처리하거나      
    전달할 수 없을 때가 발생하는데, 이런 경우 해당 메세지를 데드 레터 큐(Dead Letter Queue,DLQ)또는 데드 레터 채널로 전송하여 처리
  * 데드 레터 처리 방식은 메시지가 전달 실패한 원인을 분석하고, 시스템의 안정성을 유지하기 위한 목적으로 사용됨
  * 데드 레터 큐는 이러한 메세지를 별도로 관리하며, 시스템 운영자나 개발자가 문제를 분석하고 조치를 취할 수 있도록 함
  * 오류를 수정한 후 메시지를 원래 큐로 다시 전송하거나, 필요한 경우 메시지를 삭제할 수 있음
  * 데드 레터 처리는 시스템의 견고성을 높이고, 예기치 않은 오류로부터 시스템을 보호하는 중요한 메커니즘
  * RabbitMQ, Apache Kafka, Amazon SQS 등 대부분의 메시징 시스템과 메시지 브로커는 데드 레터 큐를 지원함
* **데드 레터로 처리되는 주요 원인**
  * 배달 실패
    * 수신자가 메시지를 받을 준비가 되어 있지 않거나, 메시지 큐가 가득 차 있는 등의 이유로 메시지를 배달할 수 없는 경우
  * 처리 실패
    * 수신자가 메시지를 올바르게 처리하지 못하는 경우,
    * 메시지 포멧 오류, 데이터 무결성 문제, 또는 예상치 못한 시스템 오류
  * 시간 초과
    * 메시지가 설정된 시간 내에 처리되지 않아 타임아웃 발생한 경우
  * 보안 제한
    * 보안 정책에 의해 메시지 처리가 거부된 경우
    
### 소프트웨어 배포 전략
* **카나리 배포**
  * 카나리 배포는 새로운 버전의 애플리케이션을 제한된 사용자 그룹에게 점진적으로 배포하는 방법
  * 목적
    * 새 버전이 넓은 사용자 베이스에 배포되기 전에 성능과 안정성을 테스트하는 것
    * 초기단계에서 문제가 발견되면, 새 버전의 배포를 즉시 중단하고 롤백할 수 있음
    * 카나리 배포는 리스크를 최소화하며, 실제 사용 환경에서의 소프트웨어 성능을 평가할 수 있게 해줌
* **블루/그린 배포**
  * 블루/그린 배포는 동시에 두개에 거의 동일한 프로뎍션 환경을 운영하는 방식
  * 하나는 현재 버전(블루)을 실행중이고, 다른 하나는 새 버전(그린)을 실행시킴
  * 배포 시, 트래픽은 새 버전이 배포된 환경(그린)으로 전환 됨
  * 목적
     * 다운타임 없이 배포를 할 수 있으며, 만약 새 버전에 문제가 발생하면 즉시 이전 버전(블루)으로 트리팩을 전환하여 롤백할 수 있음
     * 블루/그린 배포는 빠른 롤백을 가능하게 하여 배포 리스크를 줄여줌
* **롤링 업데이트**
  * 롤링 업데이트는 서비스의 인스턴스를 하나씩 순차적으로 업데이트하는 방법
  * 새 버전을 모든 인스턴스에 동시에 배포하는 대신, 일정한 비율로 점진적으로 업데이트를 진행함
  * 시스템 일부만 업데이트 되어있어도 전체 서비스가 계속 운영될 수 있게 하므로, 다운타임을 최소화 함
  * 롤링 업데이트는 특히 클러스터링된 환경이나 마이크로서비스 아키텍처에 용이함
  * 문제가 발생하는 경우, 업데이트 프로세스를 중단하고 문제가 수정될 때 까지 대기하거나, 이미 업데이트된 인스턴스를 이전 버전으로 롤백할 수 있음
 
