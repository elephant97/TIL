# 20240218(13회차) 멘토링 내용 정리📒

### JPA의 FetchType.EAGER / LAZY
* JPA의 Fetch란?
  * Entity를 조회할 때 그 Entity와 연관관계가 있는 다른 Entity의 정보를 어느 시점에 가지고 올 지 결정하는 것
  * 즉 엔티티 관계를 로딩하는 방식을 정의하는 열거형
* Fetch의 타입
  * **LAZY(지연 로딩)**
    * 게으른 이란 뜻을 가지며, 사전 의미와 같이 실제로 엔티티 조회시에 바로 가져오지 않고, 연관 관계에 있는 엔티티를 참조할 때    
      로딩함
    * 이 방식은 필요할 때만 데이터를 로딩하기 때문에 성능 최적화에 도움이 될 수 있지만, 연관된 엔티티에 접근하는 시점에서     
      추가적인 쿼리가 발생할 수 있으며, 이는 N+1문제와 같은 성능 이슈를 야기할 수 있다.
  * **EAGER(즉시 로딩)**
    * LAZY와는 반대로 엔티티 조회시에 바로 연관관계에 있는 모든 Entity를 가지고 온다.
    * 이 방식은 연관된 데이터가 항상 사용되는 경우 유용하나, 필요하지 않는 데이터까지 불러와 성능에 부정적인 영향을 줄 수 있다.

### JPA N+1문제
* **N+1 문제란?**
  * 연관관계에 있는 데이터를 조회할 때 객체를 가져오기 위한 쿼리(1번의 쿼리) + 해당 객체와 관련이 있는 객체를 가져오기 위한 쿼리(N번의 쿼리) 가 수행 됨    
  * 이 문제는 데이터가 가져와야하는 1번의 쿼리가 많아질 수록 성능에 문제를 야기함
* 해결 방법
  * 조인 사용
    * 연관된 객체를 로딩할 때 조인을 사용하여 필요한 모든 데이터를 단일 쿼리로 가져옴
    * JPA에서는 fetch join을 이용하여 구현 가능
      ```
      // EntityManager 설정
      EntityManager em = ...;
      
      // Fetch Join을 사용하여 User와 연관된 Order 객체를 함께 로딩하는 쿼리
      TypedQuery<User> query = em.createQuery(
          "SELECT u FROM User u JOIN FETCH u.orders", User.class);
      List<User> users = query.getResultList();
      ```
  * 배치 사이즈 설정
    * 지연 로딩을 사용할 때, 한 번에 로딩할 연관 객체의 수를 지정하여 N+1 쿼리 대신 적은 수의 쿼리로 필요한 데이터를 로딩할 수 있음
    ```
    @Entity
    class User {
        @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
        @BatchSize(size = 10) // 한 번에 로딩할 Order 객체의 수를 10으로 설정
        private Set<Order> orders;
    }
    ```
  * 서브 셀렉트 사용
    * 서브셀렉트 전략을 사용하여 관련 객체를 로딩할 때 필요한 모든 데이터를 가져오는 서브쿼리를 살행함.
    ```
    @Entity
    class User {
        @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
        @Fetch(FetchMode.SUBSELECT)
        private List<Order> orders;
    // 첫 번째 User의 orders에 접근할 때, 해당 User뿐만 아니라 로딩된 모든 User의 orders도 함께 로딩.
    }
    ```
