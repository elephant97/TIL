# 20240218(13회차) 멘토링 내용 정리📒

### JPA의 FetchType.EAGER / LAZY
* JPA의 Fetch란?
  * Entity를 조회할 때 그 Entity와 연관관계가 있는 다른 Entity의 정보를 어느 시점에 가지고 올 지 결정하는 것
  * 즉 엔티티 관계를 로딩하는 방식을 정의하는 열거형
* Fetch의 타입
  * **LAZY(지연 로딩)**
    * 게으른 이란 뜻을 가지며, 사전 의미와 같이 실제로 엔티티 조회시에 바로 가져오지 않고, 연관 관계에 있는 엔티티를 참조할 때    
      로딩함
    * 이 방식은 필요할 때만 데이터를 로딩하기 때문에 성능 최적화에 도움이 될 수 있지만, 연관된 엔티티에 접근하는 시점에서     
      추가적인 쿼리가 발생할 수 있으며, 이는 N+1문제와 같은 성능 이슈를 야기할 수 있다.
  * **EAGER(즉시 로딩)**
    * LAZY와는 반대로 엔티티 조회시에 바로 연관관계에 있는 모든 Entity를 가지고 온다.
    * 이 방식은 연관된 데이터가 항상 사용되는 경우 유용하나, 필요하지 않는 데이터까지 불러와 성능에 부정적인 영향을 줄 수 있다.

### JPA N+1문제
* **N+1 문제란?**
  * 연관관계에 있는 데이터를 조회할 때 객체를 가져오기 위한 쿼리(1번의 쿼리) + 해당 객체와 관련이 있는 객체를 가져오기 위한 쿼리(N번의 쿼리) 가 수행 됨    
  * 이 문제는 데이터가 가져와야하는 1번의 쿼리가 많아질 수록 성능에 문제를 야기함
* 해결 방법
  * **조인 사용**
    * 연관된 객체를 로딩할 때 조인을 사용하여 필요한 모든 데이터를 단일 쿼리로 가져옴
    * JPA에서는 fetch join을 이용하여 구현 가능
      ```
      // EntityManager 설정
      EntityManager em = ...;
      
      // Fetch Join을 사용하여 User와 연관된 Order 객체를 함께 로딩하는 쿼리
      TypedQuery<User> query = em.createQuery(
          "SELECT u FROM User u JOIN FETCH u.orders", User.class);
      List<User> users = query.getResultList();
      ```
  * **배치 사이즈 설정**
    * 지연 로딩을 사용할 때, 한 번에 로딩할 연관 객체의 수를 지정하여 N+1 쿼리 대신 적은 수의 쿼리로 필요한 데이터를 로딩할 수 있음
      ```
      @Entity
      class User {
          @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
          @BatchSize(size = 10) // 한 번에 로딩할 Order 객체의 수를 10으로 설정
          private Set<Order> orders;
      }
      ```
  * **서브 셀렉트 사용**
    * 서브셀렉트 전략을 사용하여 관련 객체를 로딩할 때 필요한 모든 데이터를 가져오는 서브쿼리를 살행함.
      ```
      @Entity
      class User {
          @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
          @Fetch(FetchMode.SUBSELECT)
          private List<Order> orders;
      // 첫 번째 User의 orders에 접근할 때, 해당 User뿐만 아니라 로딩된 모든 User의 orders도 함께 로딩.
      }
      ```

### 데드 레터(Dead Letter)
* **데드 레터란?**
  * 메시징 시스템에서 처리할 수 없는 메세지를 위한 특별한 처리 방식
  * 메시징 시스템에서는 메시지를 수신자에게 전달하려고 시도하지만, 여러가지 이유로 인해 메시지를 성공적으로 처리하거나      
    전달할 수 없을 때가 발생하는데, 이런 경우 해당 메세지를 데드 레터 큐(Dead Letter Queue,DLQ)또는 데드 레터 채널로 전송하여 처리
  * 데드 레터 처리 방식은 메시지가 전달 실패한 원인을 분석하고, 시스템의 안정성을 유지하기 위한 목적으로 사용됨
  * 데드 레터 큐는 이러한 메세지를 별도로 관리하며, 시스템 운영자나 개발자가 문제를 분석하고 조치를 취할 수 있도록 함
  * 오류를 수정한 후 메시지를 원래 큐로 다시 전송하거나, 필요한 경우 메시지를 삭제할 수 있음
  * 데드 레터 처리는 시스템의 견고성을 높이고, 예기치 않은 오류로부터 시스템을 보호하는 중요한 메커니즘
  * RabbitMQ, Apache Kafka, Amazon SQS 등 대부분의 메시징 시스템과 메시지 브로커는 데드 레터 큐를 지원함
* **데드 레터로 처리되는 주요 원인**
  * 배달 실패
    * 수신자가 메시지를 받을 준비가 되어 있지 않거나, 메시지 큐가 가득 차 있는 등의 이유로 메시지를 배달할 수 없는 경우
  * 처리 실패
    * 수신자가 메시지를 올바르게 처리하지 못하는 경우,
    * 메시지 포멧 오류, 데이터 무결성 문제, 또는 예상치 못한 시스템 오류
  * 시간 초과
    * 메시지가 설정된 시간 내에 처리되지 않아 타임아웃 발생한 경우
  * 보안 제한
    * 보안 정책에 의해 메시지 처리가 거부된 경우
    
