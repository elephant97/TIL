# 20231210(3회차) 멘토링 내용 정리📒
==> 다시 볼 부분은 💡로 표시

### Enum 
* enum은 clone() 메서드의 사용이 막혀있다
* 상속을 하지 못한다.

### 싱글턴 패턴이란?
* 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴하는 것
* DBCP(DataBase Connection Pool)과 같은 상황에서 많이 사용
* Enum을 객체로 여러번 생성하더라도 == 비교가 같은것은 Enum이 싱글턴 패튼으로 이루워져있기 때문이다.

### unmodifiable Collection
> collection을 Collection.unmodifiableList();로 생성하면 해당 메소드에서 리턴되는 컬렉션은 **Read Only** 용도로만 사용할 수 있으며, 수정하려는 메소드       
  (set(), add(), addAll())를 호출하면 **UnsupportedOperationException** 이 발생함.
* **immutable과의 차이는 무엇인가?**
  * unmodifiable은 원본 컬렉션으로의 수정 메소드를 호추할 수 없지만 **원본 리스트 자체가 수정되지 않도록 보장해주지는 않는다.**
    > 'Collection.unmodifiableList()' 메소드로 리턴받은 레퍼런스 이외의 다른 레퍼런스로는 리스트를 수정할 수 있음
  * immutable하다고 한다면 어떤 레퍼런스를 이용해서라도 수정할 수 없어야 함 따라서 unmodifiable은 immutable을 만족하지 않음.
  * 기존에 존재하는 컬렉션을 immutable하게 만들 기 위해서는 기존 컬렉션의 데이터를 다른 새로운 컬렉션으로 복사 한 다음 새로운 컬렉션으로의 수정(modify)접근을 제한하는게 일반적
  ```java
    List<String> immutableList = Collections.unmodifiableList(new ArrayList<String>(list));
  ```
  * immutable역시 copyOf를 사용해서 만든다면 객체의 원본 수정은 막을 수 없다
  ```java
    List<Integer> immutableUserIds = ImmutableList.copyOf(originUserIds);
  ```
  * 완전한 불변 객체로 만들려면 copyOf가 아닌 ImmutableList.of()로 리스트를 생성 해야함.
  ```java
    List<Integer> userIds = ImmutableList.of(1, 2);
  ```
* java9 이후로 List.of() 정적 팩토리 메서드로 불변 객체를 만들 수 있다.(java.util.List)
```java
  List<Integer> userIds = List.of(1, 2);
```

### GIT컴파일러

### 지원GC

### 리텐션폴리시
