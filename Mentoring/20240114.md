# 20240114(8회차) 멘토링 내용 정리📒

### WebMVC vs Webflux

### session clustering 
* Clustering은 여러 컴퓨터를 하나의 시스템처럼 동작하도록 하는 기술을 말한다
* Session Clustering은 각 WAS의 세션을 묶어서 관리하는 방식(세션 복제)
  * **All-to-all Session Replication**
    * 각 WAS에서 생성된 세션을 다른 WAS와 동기화 한다
    * 이렇게하면 사용자가 서버간에 이동해도 동일한 세션 정보를 유지할 수 있음
    * 사용자가 같은 묶음으로만 접속한다면 동일한 세션 데이터를 받을 수 있도록 보장함
    * 한 서버에 고정되지 않아도 되므로 트래픽 쏠림 문제에 대해 보다 자유롭고 개별 서버에 문제가 생겨도 세션 정보 유지 가능
    * **단점**
      * 세션 데이터가 저장될 때 마다 모든 서버에 해당 데이터가 입력되어야 하므로(동기화 과정) 성능저하가 올 수 있다.
      * 개별 서버 안에서도 각 서버의 세션 정보가 아닌 동일 그룹으로 모든 세션 정보를 저장해야 하므로 많은 메모리가 필요함
      * 이런 세션 클러스터링 방식을 보완하고자, 모든 was가 아닌 하나의 서버에만 세션을 동기화하고, 그 외 서버에는 세션 키만 들고있도록 하여   
        값을 백업하는 primary-sendary session 복제 방식과 세션 스토리지 방식이 존재함
  * primary-secondary Session Replication
    * 서버 1(primary)과 서버 2(primary)에 세션 객체의 key-value를 복제해두고 그 외의 서버에는 세션의 key에 해당하는 값만을 복제
    * 객체 전체를 복제했던 방식인 all-to-all 방식보다 시간이 절약된다는 장점 존재
    * **단점**
      * primary서버와 secondary서버를 제외한 서버에 세션 정보를 요청하게 되는 경우 세션 key에 해당하는 세션 객체를 얻기위해 primary서버에 질의하는 과정이 추가로 필요함
      * 위의 과정으로 인해 여전히 성능적 한계가 존재하게 됨

### Sticky Session 
* 로드밸런서가 세션 기간 동안 동일한 클라이언트의 request를 항상 동일한 서버로 라우팅 해주는 기능
* 로드밸런서는 유저가 첫번째 세션을 생성한 서버로 모든 요청을 리다이렉트 하여 고정된 세션만 사용하게 함
* 여러 서버들은 세션 데이터를 교환할 필요가 없어지며, 정합성 이슈(시스템 내에서 데이터 또는 정보가 일관되지 않은 상태)에서 자유로워 짐
* **단점**
  * 특정 서버에 과부하가 발생할 수 있으며, 트래픽이 균등하게 배분될 수 없다
  * 로드밸런싱으로 인해 트래픽이 분산되긴 하지만, Sticky Session을 사용했을 때 특정 서버에 몰린 사람만 활발한 경우 해당 서버에 과부하가 발생될 수 있다.
 
### Session storage
* 중앙집중식 세션 저장소
  * 모든 세션 정보를 중앙 데이터베이스나 캐시 시스템(Redis 등)
  * 각 WAS는 세션 생성 및 조회를 위해 중앙 저장소를 사용함
  * 세션 정보의 일관성을 유지하기 쉽지만, 중앙 저장소의 기능과 가용성이 전체 시스템의 성능과 가용성에 큰 영향을 미침

  
### 캐싱이란

### CAP란 무엇인가

### Kafka vs RabbitMQ

### 트랜잭션 phantom read 실제 테스트 해보기
* [참조링크](https://studyandwrite.tistory.com/566)
```
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void readUsers() {
        // 트랜잭션 A: 사용자 조회
        List<User> users = userRepository.findUsersByAgeGreaterThan(20);
        users.forEach(user -> System.out.println(user.getName()));

        // 잠시 대기
        try {
            Thread.sleep(10000); // 10초 대기
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 같은 쿼리 재실행
        users = userRepository.findUsersByAgeGreaterThan(20);
        users.forEach(user -> System.out.println(user.getName()));
    }

    @Transactional
    public void addUser(User user) {
        // 트랜잭션 B: 새 사용자 추가
        userRepository.save(user);
    }
}
```

### IOC
### 싱글톤 레지스트리
### DI
### 테스트는 왜 해야하는가?
### JdbcTemplate 에는 어떤 디자인패턴이 들어가있는가?
### 왜 그렇게 생각하는가?
### 그 디자인 패턴을 적용함으로써 무엇이 편해졌는가?
### 예외의 정의
### Checked Exception vs Unchecked Exception
### 예외 처리 방법들
### 트랜잭션 경계 설정
### 트랜잭션 동기화
