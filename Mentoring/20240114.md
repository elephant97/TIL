# 20240114(8회차) 멘토링 내용 정리📒

### WebMVC vs Webflux

### session clustering 
* Clustering은 여러 컴퓨터를 하나의 시스템처럼 동작하도록 하는 기술을 말한다
* Session Clustering은 각 WAS의 세션을 묶어서 관리하는 방식(세션 복제)
  * **All-to-all Session Replication**
    * 각 WAS에서 생성된 세션을 다른 WAS와 동기화 한다
    * 이렇게하면 사용자가 서버간에 이동해도 동일한 세션 정보를 유지할 수 있음
    * 사용자가 같은 묶음으로만 접속한다면 동일한 세션 데이터를 받을 수 있도록 보장함
    * 한 서버에 고정되지 않아도 되므로 트래픽 쏠림 문제에 대해 보다 자유롭고 개별 서버에 문제가 생겨도 세션 정보 유지 가능
    * **단점**
      * 세션 데이터가 저장될 때 마다 모든 서버에 해당 데이터가 입력되어야 하므로(동기화 과정) 성능저하가 올 수 있다.
      * 개별 서버 안에서도 각 서버의 세션 정보가 아닌 동일 그룹으로 모든 세션 정보를 저장해야 하므로 많은 메모리가 필요함
      * 이런 세션 클러스터링 방식을 보완하고자, 모든 was가 아닌 하나의 서버에만 세션을 동기화하고, 그 외 서버에는 세션 키만 들고있도록 하여   
        값을 백업하는 primary-sendary session 복제 방식과 세션 스토리지 방식이 존재함
  * primary-secondary Session Replication
    * 서버 1(primary)과 서버 2(primary)에 세션 객체의 key-value를 복제해두고 그 외의 서버에는 세션의 key에 해당하는 값만을 복제
    * 객체 전체를 복제했던 방식인 all-to-all 방식보다 시간이 절약된다는 장점 존재
    * **단점**
      * primary서버와 secondary서버를 제외한 서버에 세션 정보를 요청하게 되는 경우 세션 key에 해당하는 세션 객체를 얻기위해 primary서버에 질의하는 과정이 추가로 필요함
      * 위의 과정으로 인해 여전히 성능적 한계가 존재하게 됨

### Sticky Session 
* 로드밸런서가 세션 기간 동안 동일한 클라이언트의 request를 항상 동일한 서버로 라우팅 해주는 기능
* 로드밸런서는 유저가 첫번째 세션을 생성한 서버로 모든 요청을 리다이렉트 하여 고정된 세션만 사용하게 함
* 여러 서버들은 세션 데이터를 교환할 필요가 없어지며, 정합성 이슈(시스템 내에서 데이터 또는 정보가 일관되지 않은 상태)에서 자유로워 짐
* **단점**
  * 특정 서버에 과부하가 발생할 수 있으며, 트래픽이 균등하게 배분될 수 없다
  * 로드밸런싱으로 인해 트래픽이 분산되긴 하지만, Sticky Session을 사용했을 때 특정 서버에 몰린 사람만 활발한 경우 해당 서버에 과부하가 발생될 수 있다.
 
### Session storage
* 중앙집중식 세션 저장소
  * 모든 세션 정보를 중앙 데이터베이스나 캐시 시스템(Redis 등)
  * 각 WAS는 세션 생성 및 조회를 위해 중앙 저장소를 사용함
  * 세션 정보의 일관성을 유지하기 쉽지만, 중앙 저장소의 기능과 가용성이 전체 시스템의 성능과 가용성에 큰 영향을 미침

  
### 캐싱이란
* 웹 애플리케이션에서 데이터 검색 속도를 높이기 위해 사용되는 기술
* 캐싱이란 자주 접근하는 데이터를 빠르게 접근할 수 있는 메모리 기반의 시스템에 저장하는 것을 의미
* 만약 세션 스토리지로 레디스를 채택한다면, 세션 데이터를 레디스에 캐싱하고, 조회하여 사용할 수 있음
* 만약 RDB에서 자주 조회되는 데이터가 있다면 레디스에 캐싱하여 조회하면 더 빠른 성능을 가질 수 있음

### 분산데이터베이스란
* NoSQL타입의 분산 데이터베이스 시스템에서, 여러 대의 노드, 즉 여러대의 컴퓨터는 데이터베이스를 사용하는 사용자 관점에서   
  하나의 데이터베이스에 접속하는 것처럼 보여진다.
* 분산 데이터베이스는 데이터를 여러 대의 노드에 저장한다.
* 노드란 데이터베이스 인스턴스를 구동하는 물리적인 서버이며, 각 노드는 다른 노드와 서로 통신한다.
* 사용자가 데이터베이스에 쓰기 작업을 할 때, 데이터는 분산 데이터베이스를 구성하는 특정 노드에 써지며, 사용자는 어디에 데이터가 쓰여졌는 지 알지 못함
* 사용자 트래픽이 늘어남에 따라, 데이터베이스 관리자는 분산 데이터베이스 환경에 노드를 더함으로써 쉽게 수평 확장할 수 있음
  
### CAP이론
> 분산 데이터베이스 속성에 관한 이론이며, 시스템 장애로 인해 몇몇의 인스턴스가 다른 인스턴스와 통신할 수 없을 때 전체 데이터베이스를 어떻게 제어할지 결정    
> 적절한 응답 시간 내 세가지 속성을 모두 만족시키는 분산시스템을 구성할 수 없다는 이론
* Consistency(일관성), Availability(가용성), Partition Tolerance(분할 허용성)의 약자
* **Availability(가용성)**
> 언제든지 정보를 조회하고 알아낼 수 있어야 함
  * 장애 내성
    > 단일 노드의 실패가 전체 시스템의 가용성에 영향을 미치지 않도록 설계되어야 함. 하나의 노드가 실패하더라도 다른 노드가 그 역할을 대신할 수 있다
  * 데이터 복제
    > 데이터가 다수의 노드에 저장되어, 하나의 노드에 장애가 발생해도 데이터가 손실되지 않도록 보장함
  * 로드 밸런싱
    > 요청이나 작업을 시스템의 여러 노드간에 고르게 분산하여, 단일 노드에 과부하가 발생하는 것을 방지
  * 자동 장애 복구
    > 시스템은 노드 장애를 자동으로 감지하고 다른 노드로 작업을 전환하여 연속성을 유지할 수 있어야함
  * 지리적 분산
    > 데이터 센터가 다른 지역에 분산되어 있을 경우 자연재해나 지역적 장애로부터 데이터를 보호할 수 있으며, 전반적인 가능성을 높일 수 있다
  * 확장성
    > 시스템이 데이터양 증가나 요청량 증가에 맞추어 쉽게 확장될 수 있어야 함
* **Consistency(일관성)**
> 모든 노드간에 일관 데이터 상태를 유지하는 것을 의미함
  * 강한 일관성
    > 모든 노드가 항상 최신의 데이터 상태를 반영하며, 변경이 일어날 경우 모든 노드가 거의 동시에 이 변경 사항을 반영함, 성능이가 가용성을 저하시킬 수 있음
  * 약한 일관성
    > 데이터 변경 후 일정 시간이 지나거나, 특정 조건이 충족되었을 경우에만 일관성이 보장됨 성능이나 가용성을 향상시킬 수 있음
  * 최종 일관성
    > 데이터가 변경된 후 일정 시간이 지나면 모든 노드에서 최신 데이터를 볼 수 있도록 보장함
  * 트랜잭션 관리
    > ACID(Atomicity, Consistency, Isolation, Durability)속엉을 사용하여 데이터베이스 트랜잭션을 관리함으로써 일관성을 유지할 수 있음
  * 데이터 복제와 동기화
    > 데이터 복제를 통해 여러 노드에 데이터를 분산시키고, 이들 노드간에 데이터를 동기화함으로써 일관성을 유지시킴
* **Partition Tolerance(분할 허용성)**
> 네트워크 장애 또는 다른 문제로 인해 데이터베이스의 일부가 나머지 시스템과 통신할 수 없게되더라도 데이터베이스가 여전히 적절하게 작동할 수 있어야함
  * 데이터 복제 및 분산
  * 자동 장애 감지 및 복구
  * 지리적 분산
  * 로드 밸런싱 및 장애 복구 전략
    
### Kafka vs RabbitMQ
> Kafka와 RabbitMQ는 스트림 처리에 사용할 수 있는 메시지 대기열 시스템    
> 데이터 스트림은 고속 처리가 필요한 대용량의 연속적인 증분 데이터
* **RabbitMQ**
  * Message Broker의 구현체 이다
  * 전통적인 메세지 큐 방식을 지원하며, message exchange를 사용하여 pub/sub방식도 구현 함
  * 발행자가(Publisher)가 message exchange에 메시지를 보내면, 구독자(subcriber)가 메세지를 구독함
  * 여러개의 Producer와 여러개의 Consumer를 사용할 수 있다
  * 여러개의 Producer가 Message Exchange에 메세지를 보내며, 정해진 규칙에 따라 큐에 라우팅되고, Conumer들이 메세지를 처리함
* **Kafka**
  * 큐와 exchage를 기반으로 Message Broker의 구현체인 RabbitMQ와는 달리 kafka는 분산 스트리밍 플랫폼이다.
  * kafka또한 실시간 스트림 처리를 위한 Steram API 및 다양한 데이터의 손쉬운 통합을 위한 Connector API를 제공함
  * Topic
    * 카프카는 큐를 구현하지 않으며, 토픽이라고 불리는 카테고리에 데이터 집합을 저장함
    * 각가의 토픽에, 카프카는 분할된 메세지 로그를 가지고 있다.
    * 하나의 토픽에 하나의 파티션 혹은 여러개의 파티션을 가질 수 있음
    * 각 파티션은 메세지가 지속적으로 추가되며 데이터 순서가 정해져있고, 내용이 바뀌지 않는다
    * 토픽은 마치 시스템의 폴더와 유사하고, 파티션은 메세지를 저장하는 물리적 파일이다
    * 발행자는 어떤 토픽에 저장할지 선택하고 소비자는 어떤 토픽을 구독할지 정함
    * pub/sub는 토픽을 기준으로 메세지를 교환함
    * 만약에 하나의 토픽이 여러개의 파티션을 가지고 있다면, round-robin방식을 사용해서 각각 파티션에 메세지를 일관성있게 분배
  * Partition
    * 파티션들은 메세지를 저장하는 물리적 파일로 메세지 추가만 가능한 append-only속성을 가지고 있음
    * 파티션에는 각 메세지 저장 위치가 있는 오프셋이 있어서, 메세지가 어디에 저장되어 있는지 알 수 있고, 오프셋 기준으로 메세지를 순서대로 읽어 처리
    * 발행자가 넣은 메세지는 파티션의 맨 뒤에 추가 됨
    * 해당 파티션들이 소비자로 메세지를 전달하는 것이 아니라, 소비자가 polling을 통해 데이터를 가져가서 처리
    * 토픽을 소비하기 위해 함께 작동하는 소비자의 그룹을 컨슈머 그룹이라고 부름
    * 한개의 파티션은 컨슈머 그룹의 한개의 소비자만이 연결이 가능함
    * 즉 컨슈머 그룹에 속한 컨슈머들은 하나의 파티션을 공유할 수 없음
    * Kafka는 소비자가 메세지를 소비했는지 여부와 상관없이, 미리 정해진 만료시간까지 파티션에 메세지를 보관

### Kafka vs RabbitMQ 차이점
1. 동작 아키텍처
   * Kafka : Consumer -> broker -> partition -> Consumer
   * RabbitMQ : Consumer -> Exchange -> binding rules -> Queue -> Producer
2. 성능
   * Kafka : 순차적인 disk I/O 방식을 통해 성능을 향상한다. 적은 비용으로 많은 데이터 유지, 1초에 수백만개의 메세지 처리가 가능함
   * RabbitMQ : 큐가 비어있을 때만 성능이 빠르다. 1초에 수백만개 메세지 처리가 가능하지만 자원이 더 필요함
3. 메세시 순서 보장
   * Kafka
     * 같은 토픽 파티션으로 보내진 메세지는 순서대로 처리됨을 보장
     * 하지만 같은 토픽 내에 여러개의 파티션 사이에서 처리순서는 보장하지 않음(라운드 로빈으로 메세지를 분배하기 때문)
     * 만약 여러개의 파티션 사이에서 순서를 보장하고 싶다면, 키를 이용해서 메세지를 그룹하하여 동일한 키를 가진 메세지는 동일한 파티션으로 이동하도록 해야함
   * RabbitMQ
     * 메세지 소비자가 하나라면, 메세지 순서를 보장함
     * 그러나 메세지를 읽는 여러 소비자가 있으면 메세지 처리 순서에 대해 보장할 수 없음


### 트랜잭션 phantom read 실제 테스트 해보기
* [참조링크](https://studyandwrite.tistory.com/566)
```
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void readUsers() {
        // 트랜잭션 A: 사용자 조회
        List<User> users = userRepository.findUsersByAgeGreaterThan(20);
        users.forEach(user -> System.out.println(user.getName()));

        // 잠시 대기
        try {
            Thread.sleep(10000); // 10초 대기
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 같은 쿼리 재실행
        users = userRepository.findUsersByAgeGreaterThan(20);
        users.forEach(user -> System.out.println(user.getName()));
    }

    @Transactional
    public void addUser(User user) {
        // 트랜잭션 B: 새 사용자 추가
        userRepository.save(user);
    }
}
```

### IOC
### 싱글톤 레지스트리
### DI
### 테스트는 왜 해야하는가?
### JdbcTemplate 에는 어떤 디자인패턴이 들어가있는가?
### 왜 그렇게 생각하는가?
### 그 디자인 패턴을 적용함으로써 무엇이 편해졌는가?
### 예외의 정의
### Checked Exception vs Unchecked Exception
### 예외 처리 방법들
### 트랜잭션 경계 설정
### 트랜잭션 동기화
