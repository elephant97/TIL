# 20231224(5회차) 멘토링 내용 정리📒

### Proxy 패턴
> 한 객체가 다른 객체의 인터페이스를 대표하는 패턴으로, 주로 접근제어, 지연 초기화, 로깅, 네트워크 연결    
> 등과 같이 추가적인 기능을 제공하거나, 대상 객체의 사용을 간소화 하기 위해 사용된다.     
> 예를 들면, 실제 객체에 대한 접근을 관리하거나, 실제 객체의 요청을 처리하기 전에 로깅하는 등의 역할을 함

### Factory Method 패턴
> 객체 생성을 추상화 하는 패턴으로, 객체를 생성하는 인터페이스를 정의하고, 실제 객체 생성은 서브클래스에서   
> 수행하도록 한다. 이 패턴의 목적은 객체 생성 과정에 대한 유연성과 확장성을 제공하는 것으로,     
> 클라이언트 코드가 특정 클래스의 인스턴스에 직접 의존하지 않도록 해준다.     
> 예를 들어, 다양한 타입의 데이터베이스 연결을 생성하는 경우에 사용할 수 있다.

### 패턴의 사용 의도
* Proxy 패턴의 사용 의도
  1. 접근 제어
     * 프록시 패턴은 원래 객체에 대한 접근을 제어하는데 사용 된다.
     * 보안상의 이유로 직접 접근을 허용하지 않을 때 프록시를 통해 해당 객체에 대한 접근을 제어할 수 있음
  2. 지연 초기화
     * 비용이 많이 드는 객체의 생성을 지연시켜, 실제로 필요한 때만 객체를 생성함.
     * 자원 사용의 효율성을 높이는 데 도움이 됨
  3. 로깅 및 감사
     * 프록시를 사용하여 메서드를 호출을 로깅하거나 감사할 수 있음.
     * 디버깅이나 감사 목적으로 유용함.
  4. 분산 시스템 지원
     * 원격 프록시를 사용하여 네트워크를 통해 다른 서버에 있는 객체에 접근할 수 있음
* 팩터리 메서드 패턴의 사용 의도
  1. 객체 생성의 캡슐화
     * 팩터리 패턴은 객체 생성 로직을 캡슐화 하여, 클라이언트 코드가 구체적인 클래스의 인스턴스화      
       과정을 알 필요 없이 객체를 생성할 수 있도록 함.
  2. 유연성 및 확장성 향상
     * 새로운 클래스를 추가하거나 변경할 때 기존 코드를 수정할 필요 없이, 팩터리 클래스만 업데이트 하면     
       되기 때문에, 유지보수와 확장성에 유리함.
  3. 인터페이스 기반의 프로그래밍 촉진
     * 팩터리 메서드 패턴은 인터페이스나 추상 클래스를 통해 객체를 생성하므로, 프로그램의 전체적인      
       유연성이 증가하고, 구현체의 교체가 용이해짐
  4. 의존성 관리 용이
     * 의존성 주입을 사용하는 프레임 워크에서 팩터리 패턴은 객체의 생성과 의존성 관리를 쉽게 만들어 줌

### TCP는 어떻게 신뢰성을 보장하는가?
* 3 Handshake
  * TCP연결은 3 way handshake 과정을 통해 수립됨.
  * 연결을 초기화 하고, 양쪽 통신 당사자 간의 동기화를 맞추는데 사용 됨.
  * 데이터 전송이 시작되기 전에 양쪽이 서로 준비되었음을 보장함.
* 순차적 데이터 전송
  * TCP는 데이터 패킷을 순차적으로 전송함.
  * 각 데이터 세그먼트는 순차 번호로 태그가 지정되어, 수신측에서 올바른 순서로 재조립될 수 있음.
* 수신 확인 및 재전송 요청
  * TCP는 수신된 데이터에 대해 수신확인(ACK)을 보냄
  * 만약 발신측이 예상된 시간 내에 ACK를 받지 못하면 데이터가 손실되었다고 간주하고 해당 데이터를 재전송함
* 흐름제어
  * TCP는 수신측의 버퍼 크기를 고려하여 데이터 전송 속도를 조절함.
  * 수신자가 처리할 수 있는 속도 이상으로 데이터가 전송되는 것을 방지하여 데이터 손실을 줄임
* 혼잡 제어
  * 네트워크 혼잡이 발생할 경우, TCP는 데이터 전송 속도를 조절하여 혼잡을 완화함.
  * 패킷 손실이 감지되면 전송 속도를 줄임
* 오류 검출
  * TCP헤더에는 체크섬 필드(모든 데이터 바이트의 합)가 포함되어있어, 데이터가 전송 과정에서 손상되었는지    
    검사할 수 있으며, 손상된 패킷은 버려지고 재전송을 요청함.

### 3 Handshake란??
> TCP 네트워킹에서 사용되는 방법으로, 두 호스트 간의 신뢰성 있는 연결을 시작하는 과정.
* 3 Handshake의 단계
  * SYN(Synchronize)
    * 발신자 -> 수신자: 연결을 시작하려는 호스트는 다른 호스트에게 SYN 패킷을 보내며, 이 패킷에는     
      초기 순차 번호가 포함되어있음
  * SYN-ACK(Synchronize-Acknowledgment)
    * 수신자 -> 발신자: 호스트는 SYN패킷을 받고, 연결 요청을 수락한다는 의미로 SYN-ACK패킷을      
      발신자에게 보냄.
    * 이 패킷에는 호스트의 초기 순차 번호와, 받은 SYN 패킷의 순차 번호에 1을 더한 값이 ACK 번호로 설정됨.
  * ACK(Acknowledgment)
    * 발신자 -> 수신자: 마지막으로, 호스트는 다른 호스트로 부터 받은 SYN-ACK 패킷에 대한 확인으로     
      ACK패킷을 보냄.
    * 이 떄 ACK 번호는 호스트의 초기 순차번호에 1을 더한 값이다.
*이 세단계를 통해 두 호스트 간에는 신뢰성 있는 TCP 연결이 수립된다.    
3-Way handshake는 양쪽 호스트가 서로 데이터를 보내고 받을 준비가 되었으며, 초기 순차 번호가 동기화 되었음을 보장함.*

### TCP와 UDP의 차이와 장단점
* TCP
> 웹페이지 로딩, 이메일 전송, 파일 전송 등 신뢰성이 중요한 애플리케이션에서 주로 사용 됨
  * **특징**
    * 신뢰성 있는 연결 기반 프로토콜
      > TCP는 3-way handshake를 통해 연결을 수립하고 데이터 전송을 시작함
    * 데이터 순서 보장
      > 전송된 데이터의 순서가 보장되며, 분실된 패킷은 재 전송 됨
    * 흐름 제어 및 혼잡 제어
      > 네트워크 혼잡 상태와 수신자으 ㅣ버퍼 상태에 따라 데이터 전송 속도를 조절함.
  * **장점**
    * 신뢰성
      - 데이터가 손실되지 않고 정확한 순서대로 도착하는 것이 보장됨
    * 데이터 무결성
      - 체크섬을 통한 오류 검출 기능이 있어 무결성을 유지함
  * **단점**
    * 상대적으로 느린 속도
      - 연결 설정, 데이터 순서 조정, 재전송 등으로 인해 UDP보다 속도가 느림
    * 더 많은 시스템 자원 소모
      - 연결 유지 및 상태 추적이 필요 함
* UDP
> 스트리밍, 온라인 게임, VoIP등 실시간성이 중요하고 일부 데이터 손실이 허용되는 애플리케이션에서 사용
  * **특징**
    * 비연결 지향 프로토콜
      > 연결을 설정하지 않고 데이터를 전송함
    * 경량 프로토콜
      > 최소한의 프로토콜 메커니즘 만을 가지고 있음
    * 순서 보장 및 재전송 없음
      > 전송된 데이터의 순서가 보장되지 않으며, 데이터 손실 시 재전송을 하지 않음
  * **장점**
    * 빠른 전송 속도
      - 연결 설정이 없고 흐름 제어 및 혼잡 제어가 없어 처리 속도가 빠름
    * 간단한 구현
      - 프로토콜이 간단하여 구현이 용이함
    * 리소스 요구량이 낮음
      - 연결 상태를 유지할 필요가 없어 시스템 자원을 적게 사용함
  * **단점**
    * 신뢰성 부족
      - 데이터 분실 시 재전송 하지 않아 신뢰성이 낮다.
    * 데이터 순서와 무결성 미보장
      - 데이터가 순서대로 도착한다는 보장이 없으며, 데이터 무결성 검사 기능이 제한적

### HTTP/2 와 HTTP/3는 무엇인가
* HTTP/2
> HTTP/1.x의 직접적인 후속 버전으로 2015년에 표준화 되었음.
  * 다중화(Multiplexing)
    * 하나의 TCP 연결을 통해 여러개의 요청과 응답을 동시에 전송할 수 있음
    * 여러 리소스를 병렬로 로드하면서도 연결 수를 줄일 수 있어 성능을 향상시킴
  * 스트림 우선 순위
    * 클라이언트는 요청의 우선 순위를 지정할 수 있어, 중요한 리소스부터 먼저 로드될 수 있게 함
  * 서버 푸시
    * 서버가 클라이언트에게 필요한 리소스를 클라이언트 요청 전에 미리 보낼 수 있음
    * 여러 요청-응답 트립을 줄일 수 있음
  * 헤더 압축
    * HTTP/2는 HPACK 압축 포맷을 사용하여 헤더 데이터를 압축함
    * 전송해야 할 데이터의 양을 줄여 성능을 개선함
* HTTP/3
> HTTP/2의 후속 버전으로, 현재 개발중에 있음. 가장 큰 변화는 TCP 대신 QUIC프로토콜을 사용하는 것임    
> QUIC는 UDP 기반의 프로토콜이다. 모바일 환경이나 네트워크가 불안정한 환경에서의 웹 성능을 개선하는데 중점을 둠
  * 개선된 연결 설정
    * QUIC는 연결 설정에 필요한 라운드 트립을 줄여 특히 새로운 연결을 자주 만드는 상황에서 성능을 향상시킴
  * 연결 마이그레이션
    * IP주소나 포트 변경시에도 기존 QUIC연결을 유지할 수 있음
  * 향상된 다중화
    * QUIC는 헤더 압축과 함께 각 스트림의 독립적인 흐름 제어를 제공함
    * 특정 스트림에서의 데이터 손실이 다른 스트림에 영향을 주지 않도록 함
  * 손실 감지와 복구 개선
    * QUIC는 TCP보다 더 효율적인 손실 감지 및 복구 메커니즘을 제공함

### 소켓이란 무엇인가?
> 소켓은 네트워크 상에서 서로 다른 시스템 간에 데이터를 주고받기 위한 엔드포인트를 제공하는 네트워크 통신의   
> 기본 단위이며, 네트워크를 통해 데이터를 송수신하는 과정에서 소프트웨어적인 연결 지점의 역할을 함.    
> 소켓을 통해 애플리케이션은 네트워크 프로토콜을 사용하여 데이터를 송수신 할 수 있음

### 소켓을 사용하는 이유
> 소켓은 네트워크 상에서 서로 다른 시스템 간의 데이터를 신뢰성 있게 주고받기 위한 표준화된 인터페이스를 제공하기 때문
*TCP로 HTTP통신을 짜려면 직접 헤더 HTTP규약에 맞는 헤더 구성을 직접 해주어야만 한다*
* 네트워크 통신 활성화
  * 소켓은 다양한 네트워트 프로토콜을 통해 두 시스템 간의 데이터 교환을 가능하게 한다
  * 원격 서버와 클라이언트 사이, 또는 분산 시스템 내의 서로 다른 애플리케이션 간에 통신을 할 수 있음
* 표준화된 프로그래밍 인터페이스
  * 소켓은 네트워크 통신을 위한 일관된 프로그래밍 인터페이스(API)를 제공함
  * 이를 통해 개발자는 하드웨어나 네트워크 프로토콜의 복잡성을 신경쓰지 않고 통신 기능을 구현할 수 있음
* 양방향 통신
  * TCP 소켓을 사용하는 경우, 신뢰성 있는 양방향 통신이 가능하다.
  * 데이터의 순서와 무결성이 보정되며, 연결이 유지되는 동안 지속적인 데이터 교환이 가능함.
* 다양한 네트워크 어플리케이션 개발
  * 웹 서버, 이메일 서버, 파일 전송, 스트리밍 서비스 등 다양한 네트워크 기발 애플리케이션 개발에 소켓이 필수적
* 플랫폼 및 언어 독립성
  * 소켓 프로그래밍은 대부분의 운영 체제와 프로그래밍 언어에서 지원되므로, 다양한 플랫폼과 언어 간의 통신이 용이
* 분산시스템 지원
  * 소켓은 분산 컴퓨팅 환경에서 서로 다른 시스템 간의 통신을 지원하여, 리소스 공유, 원격 작업 실행, 분산 데이터 처리 등의 작업을 가능하게 함.
* 유연성 및 확장성
  * 소켓은 다양한 네트워크 아키텍처와 프로토콜에 적용할 수 있으며, 새로운 기술이나 프로토콜로의 확장이 용이.

### 웹소켓과 TCP의 차이
* 웹소켓
> 웹 애플리케이션에서 브라우저와 서버 간의 양방향 통신을 가능하게 하는 고급 프로토콜
  * 작동방식
    * 웹 소켓은 처음에는 HTTP 프로토콜을 사용하여 헨드셰이크를 수행한 후, 그 연결을 웹소켓 프로토콜로 업그레이드 함.
    * 이를 통해 지속적이고 실시간 양방향 통신 채널을 만든다.
* TCP와의 차이점
  * 수준
    * TCP는 더 낮은 수준의 전송 프로토콜로, 인터넷의 기본적인 데이터 전송 메커니즘을 제공함.
    * 반면 웹 소켓은 웹 애플리케이션을 위한 더 높은 수준의 프로토콜이다.
  * 목적
    * TCP는 네트워크의 기본적인 데이터 전송을 담당하는 반면, 웹소켓은 웹 애플리케이션에서 실시간 양방향 통신을 가능하게 하는 것을 목표로 함.
  * 연결방식
    * TCP는 연결 지향적이며 신뢰성 있는 통신을 제공하는 반면, 웹 소켓은 HTTP 연결을 업그레이드 하여 양방향 통신 채널을 만듬
  * 사용사례
    * TCP는 인터넷 상의 다양한 애플리케이션에서 사용되는 기본적인 프로토콜이며, 웹소켓은 주로 웹 기반 실시간 양방향 통신에 사용 됨.

### 웹소켓 프로토콜로의 업그레이드 과정
> 클라이언트와 서버간의 초기 HTTP 핸드셰이크를 통해 이루어짐.     
> 이 과정에서 클라이언트는 웹소켓 연결을 요청하고, 서버가 이를 수락함으로써 HTTP연결이 웹 소켓으로 전환 됨
1. 클라이언트에서의 웹 소켓 연결 요청
> 클라이언트는 서버에 HTTP GEP요청을 보내고, 이 요청에는 웹소켓 연결을 위한 특별한 헤더들이 포함 됨.
  * Upgrade: websocket
    * HTTP 프로토콜을 웹소켓 프로토콜로 업그레이드하고자 함을 나타냄
  * Connection: Upgrade
    * 현재의 연결을 유지하면서 프로토콜을 전환하고자 함을 나타냄
  * Sec-WebSocket-Key
    * 서버에 의해 사용되어 응답을 생성하는데 사용되는 무작위로 인코딩 된 값.
  * Sec-WebSokcet-Version
    * 클라이언트가 사용하는 웹소켓 프로토콜의 버전을 명시함
2. 서버에서의 응답 및 프로토콜 업그레이드
> 서버가 웹소켓 연결을 지원하고 클라이언트의 요청을 수락하는 경우, 다음과 같은 HTTP 응답을 보냄
  * HTTP/1.1 101 Switching Protocols
    * 서버가 웹소켓 프로토콜의 업그레이드를 확인함
  * Upgrade: websocket
    * 서버가 웹 소켓 프로토콜로의 업그레이드를 확인함.
  * Connection: Upgrade
    * 형재의 연결이 웹소켓 연결로 전환됨을 나타냄
  * Sec-WebSocket-Accept
    * 클라이언트의 Sec-WebSocket-Key헤더 값을 기반으로 생성된 값이며, 클라이언트가 서버의 응답을 확인하는데 사용
3. 웹 소켓 연결의 시작
> 위의 핸드셰이크 과정이 성공적으로 완료되면, HTTP연결은 웹소켓 연결로 업그레이드 되며,     
> 이후의 데이터 교환은 웹소켓 프로토콜을 통해 이루어짐.     
> 이 시점부터 클라이언트와 서버 간에는 실시간, 양방향 통신이 가능해짐

### 웹소켓 프로토콜로의 업그레이드 과정이 왜 필요한가?
> 웹 통신에서 실시간, 양방향 통신을 가능하게 하기위해 필요함
* HTTP의 제한 극복
  * 기존의 HTTP 프로토콜은 요청-응답기반으로 작동함
  * 이는 클라이언트가 요청을 보내고 서버가 응답하는 단방향 통신만을 지원함
  * 웹소켓은 이러한 HTTP의 제한을 극복하고, 서버와 클라이언트 간의 지속적이고 양방향 통신을 가능하게 함
* 실시간 데이터 교환
  * 많은 현대 웹 애플리케이션은 실시간으로 데이터를 교환해야 하는 필요성이 있음
  * 실시간 통신 요구사항을 충족시키기 위해 필요함
* 네트워크 효율성 향상
  * 웹소켓은 연결을 한번만 수립하고 이를 지속적으로 유지함
  * 매번의 HTTP요청마다 새로운 연결을 만드는 것보다 네트워크 자원을 효율적으로 사용하게 함
* 낮은 지연시간
  * 웹소켓은 연결이 지속되는 한, 데이터를 빠르게 주고받을 수 있어 지연시간을 최소화함.
  * 특히 인터랙티브한 애플리케이션에서 중요한 요소임
* 서버 푸시 기능
  * 전통적인 HTTP통신에서는 클라이언트가 먼저 요청을 보내야 서버가 응답할 수 있음
  * 웹소켓을 통해 서버는 클라이언트의 요청 없이도 데이터를 클라이언트에게 푸시할 수 있음
   
### Read Timeout이란 무엇인가?
> 네트워크 통신에서 데이터를 읽는데 걸리는 최대 시간을 나타냄      
> 구체적으로 클라이언트가 서버로부터 데이터를 수신하는 데 필요한 시간이 설정된 제한 시간을 초과하는 경우 발생하는 시간 초과 오류
* 사용 이유
  * 자원의 효율적 관리
    * 클라이언트가 무한정 서버의 응답을 기다리지 않고, 시간이 초과되면 다음 작업을 진행할 수 있게 함
    * 자원의효율적 사용과 애플리케이션의 반응성을 높이는데 도움이 됨

### 비대칭키 암호화와 대칭키 암호화란?
* 비대칭키 암호화
> 공개키와 비밀키를 사용하여 공개키는 모두에게 공개되며 데이터를 암호화하는데 사용되고,    
> 비밀키는 데이터를 복호화하는데 사용함. 공개키로 암호화된 데이터는 오직 공개키와 쌍을 이루는 비밀키로만 복호화가능
  * 장점
    * 보안성: 공개키와 비밀키의 쌍이 있어, 키 배포의 어려움 없이 안전한 통신이 가능함
    * 키 관리 용이성: 공개키는 안전하게 공유될 수 있으며, 비밀키는 개인이 보유 됨.
  * 단점
    * 속도: 대칭키 암호화보다 계산이 복잡하여 처리 속도가 느림
    * 계산 자원 요구: 더 많은 계산 자원을 요구함
  * 사용 상황
    * 보안이 중요하고 키 교환의 어려움을 피하고자 하는 상황에 적합
* 대칭키 암호화
> 암호화 복호화에 같은 키를 사용함.
  * 장점
    * 속도: 대칭키 암호화는 계산이 빠르고 단순함
    * 효율성: 대량의 데이터를 빠르게 처리할 수 있어 대용량 데이터 암호화에 적합함
  * 단점
    * 키 관리 문제: 암호화 키를 안전하게 교환하고 관리해야 함
    * 키 배포의 어려움: 통신하는 각 당사자 간에 안전한 방법으로 키를 공유해야 함
  * 사용 상황
    * 빠른 처리 속도가 필요하고 키 교환 문제가 해결되는 상황에 적합

### RSA알고리즘
> 비대칭키 암호화 방식 중 하나. 큰 소수의 곱을 기반으로 하며, 현재 기술로는 이를 효율적으로 분해할 방법이 없어 매우 안전 함.

### try with resources
* AutoCloseable 인터페이스 구현하고 있는 메서드에 한해 try(..)구문에 작성 시 try블록이 종료될 때 자동으로 호출 됨
* 예외처리를 별도로 구현할 필요가 없어 효율적이며 코드가 간결해지고, 자원의 누수를 방지 할 수 있음

### Date가 deprecated된 이유
* 스레드 안전문제
  * 해당 클래스는 스레드 안전하지 않아 동기화 문제가 발생할 수 있음
* 설계상의 결함
  * 날짜와 시간을 관리하는데 필요한 많은 기능을 제공하지 않음
  * 월을 나타내는 인덱스가 0에서부터 시작하여 혼란을 주고, 날짜와 시간을 조작하는 메서드가 충분하지 않음
* 시간대 처리 미흡
  * UTC시간 기준으로 시간을 저장하지만 시간대 변환에 대한 기능이 부족함
* 불변 객체가 아님
  * Date는 변경가능하며, 한번 생성된 후에도 내부 상태가 변경될 수 있어 버그발생이나 데이터 무결성을 유지하기 어렵게 만듬

### Optional을 사용하는 이유
> 값의 존재 혹은 부재를 더 안전하게 다루기 위해서 사용함
* Null 참조의 문제 해결
  * 값이 있거나 없을 수 있는 객체를 래핑하고 이를 명시적으로 표현함으로 써 null관련 버그 예방 가능
* 명시적 API
  * 이 메서드가 null값을 반환할 수 있음을 명시적으로 나타낼 수 있다
* 함수형 프로그래밍 지원
  * Optional은 map, flatMap, filter등의 함수형 프로그래밍 메서드를 제공함
  * 이를 통해 값을 조건부로 변환하거나, 여러 Optional 객체를 연결하는 등의 작업을 보다 선언적으로 처리 가능
* 체이닝 메서드
  * Optional은 메서드 체이닝을 지원하여 값의 존재 여부에 따라 다른 동작을 연속적으로 수행할 수 있게 해줌

### Servlet이란?
> 자바를 이용하여 웹 서버에서 동적인 웹 페이지를 생성하기 위한 서버 사이드 컴포넌트 이다.     
> HTTP요청을 받아 처리하고 그 결과를 HTTP 응답으로 웹 클라이언트에 돌려주는 역할을 한다
* 서블릿은 주로 HTML, XML, JSON과 같은형식으로 클라이언트에게 데이터를 제공하기 위해 사용 됨
* 서블릿은 생명 주기 메서드를 ㅏㅈ고있어 웹 서버에 의해 관리 됨
* 서블릿의 주요 장점은 성능과 확장서이다. 한번 로드되면, 서블릿은 메모리에 유지되며 이후 들어오는 HTTP요청은 새로운 스레드에서 처리 됨
* 서블릿이 자원을 효율적으로 사용하면서도 높은 성능을 제공할 수 있음을 뜻함
* MVC패턴에서 웹 애플리케이션의 컨트롤러로  자주 사용 됨

### 서버사이드랜더링과 클라이언트 사이드 랜더링
* **서버사이드 랜더링(SSR)**
> SSR에서는 웹 페이지의 콘텐츠가 서버에서 HTML 형태로 렌더링 되고, 이렇게 완성된 페이지가 클라이언트에 전송 됨
  * 장점
    * 빠른 첫 페이지 로드: 초기 콘텐츠가 서버에서 완전히 렌더링 되어 전송되므로, 페이지를 빠르게 볼 수 있음
    * SEO 최적화: 검색 엔진이 페이지의 콘텐츠를 쉽게 인덱싱 할 수 있어 SEO에 유리
  * 단점
    * 서버부하: 각 요청마다 서버에서 페이지를 새로 렌더링 해야 하므로, 서버 부하가 높아질 수 있음
    * 동적인 상호작용 제한: 페이지의 동적인 상호작용을 위해서는 추가적인 자바 스크립트 필요
* **클라이언트 사이드 랜더링(CSR)**
> HTML의 기본 구조와 자바스크립트가 서버에서 클라이언트로 전송되고, 자바스크립트가 브라우저에서 실행되면서 페이지의 콘텐츠를 생성함
  * 장점
    * 서버 부하 감소: 초기 요청 이후의 페이지 렌더링은 클라이언트 측에서 처리되므로 서버 부하가 감소 됨
    * 사용자 경험: 한번의 페이지 로드 후에는 자바 스크립트를 통해 콘텐츠를 동적으로 변경 가능하여 사용자의 경험이 향상 됨
  * 단점
    * 느린 초기 로딩: 자바스크립트와 필요한 데이터를 모두 불러온 후에 콘텐츠가 렌더링 되므로 초기 로딩이 느릴 수 있음
    * SEO문제: 검색 엔진이 자바스크립트를 실행하지 않는 경우, 페이지 콘텐츠를 제대로 인덱싱 하지 못할 수 있어 SEO에 불리할 수 있음

*SEO란 Search Engine Optimization, 검색엔진 최적화를 뜻함*

### 롬복
> 보일러플레이트 코드(반복적으로 작성되는 코드)를 줄이기 위해 사용하는 라이브러리.    
> 다양한 편의 기능을 제공하여, 개발자가 더 깔끔하고 유지보수가 쉬운 코드를 작성할 수 있게 도와줌
* 비지니스 로직 개발에 더 집중할 수 있게 해줌

### Stream
* 코드의 간결성 및 가독성 향상
  * 복잡한 데이터 처리 로직을 몇 줄의 코드로 간결하게 표현할 수 있다
  * 코드의 가독성을 크게 향상시키고, 유지보수를 용이하게 함
* 선언적인 데이터 처리
  * 함수형 프로그래밍 접근 방식을 채택하여, 개발자가 "무엇을(What)" 처리할지에 초점을 맞출 수 있게 해줌
* 병렬 처리 지원
  * 데이터를 병렬로 처리할 수 있는 기능을 내장하고 있어, 멀티코어 프로세서의 이점을 쉽게 활용할 수 있음
  * 데이터 처리 성능을 향상시킬 수 있음
* 연산 체이닝
  * 여러 데이터 처리 연산(필터링, 매핑, 정렬, 집계 등)을 체인처럼 연결할 수 있어, 복잡한 데이터 처리 파이프라인을 효과적으로 구성할 수 있다.
* 무상태 및 상태 있는 연산
  * 필터링이나 매핑과 같은 무상태 연산 뿐만 아니라, 정렬이나 중복 제거와 같은 상태 있는 연산도 지원

### Fork / Join은 무엇이며 어떻게 병렬처리 하고 있나?
> 자바에서 병렬 처리를 위해 사용되는 프로그래밍 모델로, 큰 작업을 작은 작업으로 분할(fork)한 후, 이들을 병렬로 처리하고, 결과를 합쳐(join) 최종 결과를 도출하는 방식
* 분할된 작업은 ForkJoinPool의 작업 큐에 추가
* ForkJoinPool 내의 스레드들은 작업 큐에 있는 작업들을 가져와 병렬로 실행
* ForkJoinPool은 작업 도둑질(Work Stealing) 알고리즘을 사용
* 한 스레드가 다른스레드의 작업 큐에서 가져와 처리할 수 있게 해줌으로써 모든 스레드가 바쁘게 유지되도록 함

### 아래 코드에서 의도대로 흘러가지 않을 떄는 어떤 때인가?
```java
public boolean isDuplicated(int input, Set<Integer> validSet, Set<Integer> invalidSet) {
    // Set은 모두 ConcurrentHashSet 이기 때문에 Atomic Operation 을 보장
    if(validSet.contains(input)) {
        invalidSet.add(input);
        return true;
    }
    else {
        validSet.add(input);
        return false;
    }
}
```
