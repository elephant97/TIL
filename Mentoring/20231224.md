# 20231224(5회차) 멘토링 내용 정리📒

### Proxy 패턴
> 한 객체가 다른 객체의 인터페이스를 대표하는 패턴으로, 주로 접근제어, 지연 초기화, 로깅, 네트워크 연결    
> 등과 같이 추가적인 기능을 제공하거나, 대상 객체의 사용을 간소화 하기 위해 사용된다.     
> 예를 들면, 실제 객체에 대한 접근을 관리하거나, 실제 객체의 요청을 처리하기 전에 로깅하는 등의 역할을 함

### Factory Method 패턴
> 객체 생성을 추상화 하는 패턴으로, 객체를 생성하는 인터페이스를 정의하고, 실제 객체 생성은 서브클래스에서   
> 수행하도록 한다. 이 패턴의 목적은 객체 생성 과정에 대한 유연성과 확장성을 제공하는 것으로,     
> 클라이언트 코드가 특정 클래스의 인스턴스에 직접 의존하지 핞도록 해준다.     
> 예를 들어, 다양한 타입의 데이터베이스 연결을 생성하는 경우에 사용할 수 있다.

### 패턴의 사용 의도
* Proxy 패턴의 사용 의도
  1. 접근 제어
     * 프록시 패턴은 원래 객체에 대한 접근을 제어하는데 사용 된다.
     * 보안상의 이유로 직접 접근을 허용하지 않을 때 프록시를 통해 해당 객체에 대한 접근을 제어할 수 있음
  2. 지연 초기화
     * 비용이 많이 드는 객체의 생성을 지연시켜, 실제로 필요한 때만 객체를 생성함.
     * 자원 사용의 효율성을 높이는 데 도움이 됨
  3. 로깅 및 감사
     * 프록시를 사용하여 메서드를 호출을 로깅하거나 감사할 수 있음.
     * 디버깅이나 감사 목적으로 유용함.
  4. 분산 시스템 지원
     * 원격 프록시를 사용하여 네트워크를 통해 다른 서버에 있는 객체에 접근할 수 있음
* 팩터리 메서드 패턴의 사용 의도
  1. 객체 생성의 캡슐화
     * 팩터리 패턴은 객체 생성 로직을 캡슐화 하여, 클라이언트 코드가 구체적인 클래스의 인스턴스화      
       과정을 알 필요 없이 객체를 생성할 수 있도록 함.
  2. 유연성 및 확장성 향상
     * 새로운 클래스를 추가하거나 변경할 때 기존 코드를 수정할 필요 없이, 팩터리 클래스만 업데이트 하면     
       되기 때문에, 유지보수와 확장성에 유리함.
  3. 인터페이스 기반의 프로그래밍 촉진
     * 팩터리 메서드 패턴은 인터페이스나 추상 클래스를 통해 객체를 생성하므로, 프로그램의 전체적인      
       유연성이 증가하고, 구현체의 교체가 용이해짐
  4. 의존성 관리 용이
     * 의존성 주입을 사용하는 프레임 워크에서 팩터리 패턴은 객체의 생성과 의존성 관리를 쉽게 만들어 줌

### TCP는 어떻게 신뢰성을 보장하는가?
* 3 Handshake
  * TCP연결은 3 way handshake 과정을 통해 수립됨.
  * 연결을 초기화 하고, 양쪽 통신 당사자 간의 동기화를 맞추는데 사용 됨.
  * 데이터 전송이 시작되기 전에 양쪽이 서로 준비되었음을 보장함.
* 순차적 데이터 전송
  * TCP는 데이터 패킷을 순차적으로 전송함.
  * 각 데이터 세그먼트는 순차 번호로 태그가 지정되어, 수신측에서 올바른 순서로 재조립될 수 있음.
* 수신 확인 및 재전송 요청
  * TCP는 수신된 데이터에 대해 수신확인(ACK)을 보냄
  * 만약 발신측이 예상된 시간 내에 ACK를 받지 못하면 데이터가 손실되었다고 간주하고 해당 데이터를 재전송함
* 흐름제어
  * TCP는 수신측의 버퍼 크기를 고려하여 데이터 전송 속도를 조절함.
  * 수신자가 처리할 수 있는 속도 이상으로 데이터가 전송되는 것을 방지하여 데이터 손실을 줄임
* 혼잡 제어
  * 네트워크 혼잡이 발생할 경우, TCP는 데이터 전송 속도를 조절하여 혼잡을 완화함.
  * 패킷 손실이 감지되면 전송 속도를 줄임
* 오류 검출
  * TCP헤더에는 체크섬 필드(모든 데이터 바이트의 합)가 포함되어있어, 데이터가 전송 과정에서 손상되었는지    
    검사할 수 있으며, 손상된 패킷은 버려지고 재전송을 요청함.

### 3 Handshake란??
> TCP 네트워킹에서 사용되는 방법으로, 두 호스트 간의 신뢰성 있는 연결을 시작하는 과정.
* 3 Handshake의 단계
  * SYN(Synchronize)
    * 발신자 -> 수신자: 연결을 시작하려는 호스트는 다른 호스트에게 SYN 패킷을 보내며, 이 패킷에는     
      초기 순차 번호가 포함되어있음
  * SYN-ACK(Synchronize-Acknowledgment)
    * 수신자 -> 발신자: 호스트는 SYN패킷을 받고, 연결 요청을 수락한다는 의미로 SYN-ACK패킷을      
      발신자에게 보냄.
    * 이 패킷에는 호스트의 초기 순차 번호와, 받은 SYN 패킷의 순차 번호에 1을 더한 값이 ACK 번호로 설정됨.
  * ACK(Acknowledgment)
    * 발신자 -> 수신자: 마지막으로, 호스트는 다른 호스트로 부터 받은 SYN-ACK 패킷에 대한 확인으로     
      ACK패킷을 보냄.
    * 이 떄 ACK 번호는 호스트의 초기 순차번호에 1을 더한 값이다.
*이 세단계를 통해 두 호스트 간에는 신뢰성 있는 TCP 연결이 수립된다.    
3-Way handshake는 양쪽 호스트가 서로 데이터를 보내고 받을 준비가 되었으며, 초기 순차 번호가 동기화 되었음을 보장함.*

### TCP와 UDP의 차이와 장단점
* TCP
> 웹페이지 로딩, 이메일 전송, 파일 전송 등 신뢰성이 중요한 애플리케이션에서 주로 사용 됨
  * **특징**
    * 신뢰성 있는 연결 기반 프로토콜
      > TCP는 3-way handshake를 통해 연결을 수립하고 데이터 전송을 시작함
    * 데이터 순서 보장
      > 전송된 데이터의 순서가 보장되며, 분실된 패킷은 재 전송 됨
    * 흐름 제어 및 혼잡 제어
      > 네트워크 혼잡 상태와 수신자으 ㅣ버퍼 상태에 따라 데이터 전송 속도를 조절함.
  * **장점**
    * 신뢰성
      - 데이터가 손실되지 않고 정확한 순서대로 도착하는 것이 보장됨
    * 데이터 무결성
      - 체크섬을 통한 오류 검출 기능이 있어 무결성을 유지함
  * **단점**
    * 상대적으로 느린 속도
      - 연결 설정, 데이터 순서 조정, 재전송 등으로 인해 UDP보다 속도가 느림
    * 더 많은 시스템 자원 소모
      - 연결 유지 및 상태 추적이 필요 함
* UDP
> 스트리밍, 온라인 게임, VoIP등 실시간성이 중요하고 일부 데이터 손실이 허용되는 애플리케이션에서 사용
  * **특징**
    * 비연결 지향 프로토콜
      > 연결을 설정하지 않고 데이터를 전송함
    * 경량 프로토콜
      > 최소한의 프로토콜 메커니즘 만을 가지고 있음
    * 순서 보장 및 재전송 없음
      > 전송된 데이터의 순서가 보장되지 않으며, 데이터 손실 시 재전송을 하지 않음
  * **장점**
    * 빠른 전송 속도
      - 연결 설정이 없고 흐름 제어 및 혼잡 제어가 없어 처리 속도가 빠름
    * 간단한 구현
      - 프로토콜이 간단하여 구현이 용이함
    * 리소스 요구량이 낮음
      - 연결 상태를 유지할 필요가 없어 시스템 자원을 적게 사용함
  * **단점**
    * 신뢰성 부족
      - 데이터 분실 시 재전송 하지 않아 신뢰성이 낮다.
    * 데이터 순서와 무결성 미보장
      - 데이터가 순서대로 도착한다는 보장이 없으며, 데이터 무결성 검사 기능이 제한적

### HTTP/2 와 HTTP/3는 무엇인가
* HTTP/2
> HTTP/1.x의 직접적인 후속 버전으로 2015년에 표준화 되었음.
  * 다중화(Multiplexing)
    * 하나의 TCP 연결을 통해 여러개의 요청과 응답을 동시에 전송할 수 있음
    * 여러 리소스를 병렬로 로드하면서도 연결 수를 줄일 수 있어 성능을 향상시킴
  * 스트림 우선 순위
    * 클라이언트는 요청의 우선 순위를 지정할 수 있어, 중요한 리소스부터 먼저 로드될 수 있게 함
  * 서버 푸시
    * 서버가 클라이언트에게 필요한 리소스를 클라이언트 요청 전에 미리 보낼 수 있음
    * 여러 요청-응답 트립을 줄일 수 있음
  * 헤더 압축
    * HTTP/2는 HPACK 압축 포맷을 사용하여 헤더 데이터를 압축함
    * 전송해야 할 데이터의 양을 줄여 성능을 개선함
* HTTP/3
> HTTP/2의 후속 버전으로, 현재 개발중에 있음. 가장 큰 변화는 TCP 대신 QUIC프로토콜을 사용하는 것임    
> QUIC는 UDP 기반의 프로토콜이다. 모바일 환경이나 네트워크가 불안정한 환경에서의 웹 성능을 개선하는데 중점을 둠
  * 개선된 연결 설정
    * QUIC는 연결 설정에 필요한 라운드 트립을 줄여 특히 새로운 연결을 자주 만드는 상황에서 성능을 향상시킴
  * 연결 마이그레이션
    * IP주소나 포트 변경시에도 기존 QUIC연결을 유지할 수 있음
  * 향상된 다중화
    * QUIC는 헤더 압축과 함께 각 스트림의 독립적인 흐름 제어를 제공함
    * 특정 스트림에서의 데이터 손실이 다른 스트림에 영향을 주지 않도록 함
  * 손실 감지와 복구 개선
    * QUIC는 TCP보다 더 효율적인 손실 감지 및 복구 메커니즘을 제공함

### 소켓이란 무엇인가?
> 소켓은 네트워크 상에서 서로 다른 시스템 간에 데이터를 주고받기 위한 엔드포인트를 제공하는 네트워크 통신의   
> 기본 단위이며, 네트워크를 통해 데이터를 송수신하는 과정에서 소프트웨어적인 연결 지점의 역할을 함.    
> 소켓을 통해 애플리케이션은 네트워크 프로토콜을 사용하여 데이터를 송수신 할 수 있음

### 소켓을 사용하는 이유
> 소켓은 네트워크 상에서 서로 다른 시스템 간의 데이터를 신뢰성 있게 주고받기 위한 표준화된 인터페이스를 제공하기 때문
* 네트워크 통신 활성화
  * 소켓은 다양한 네트워트 프로토콜을 통해 두 시스템 간의 데이터 교환을 가능하게 한다
  * 원격 서버와 클라이언트 사이, 또는 분산 시스템 내의 서로 다른 애플리케이션 간에 통신을 할 수 있음
* 표준화된 프로그래밍 인터페이스
  * 소켓은 네트워크 통신을 위한 일관된 프로그래밍 인터페이스(API)를 제공함
  * 이를 통해 개발자는 하드웨어나 네트워크 프로토콜의 복잡성을 신경쓰지 않고 통신 기능을 구현할 수 있음
* 양방향 통신
  * TCP 소켓을 사용하는 경우, 신뢰성 있는 양방향 통신이 가능하다.
  * 데이터의 순서와 무결성이 보정되며, 연결이 유지되는 동안 지속적인 데이터 교환이 가능함.
* 다양한 네트워크 어플리케이션 개발
  * 웹 서버, 이메일 서버, 파일 전송, 스트리밍 서비스 등 다양한 네트워크 기발 애플리케이션 개발에 소켓이 필수적
* 플랫폼 및 언어 독립성
  * 소켓 프로그래밍은 대부분의 운영 체제와 프로그래밍 언어에서 지원되므로, 다양한 플랫폼과 언어 간의 통신이 용이
* 분산시스템 지원
  * 소켓은 분산 컴퓨팅 환경에서 서로 다른 시스템 간의 통신을 지원하여, 리소스 공유, 원격 작업 실행, 분산 데이터 처리 등의 작업을 가능하게 함.
* 유연성 및 확장성
  * 소켓은 다양한 네트워크 아키텍처와 프로토콜에 적용할 수 있으며, 새로운 기술이나 프로토콜로의 확장이 용이.

### 웹소켓과 TCP의 차이
* 웹소켓
> 웹 애플리케이션에서 브라우저와 서버 간의 양방향 통신을 가능하게 하는 고급 프로토콜
  * 작동방식
    * 웹 소켓은 처음에는 HTTP 프로토콜을 사용하여 헨드셰이크를 수행한 후, 그 연결을 웹소켓 프로토콜로 업그레이드 함.
    * 이를 통해 지속적이고 실시간 양방향 통신 채널을 만든다.
* TCP와의 차이점
  * 수준
    * TCP는 더 낮은 수준의 전송 프로토콜로, 인터넷의 기본적인 데이터 전송 메커니즘을 제공함.
    * 반면 웹 소켓은 웹 애플리케이션을 위한 더 높은 수준의 프로토콜이다.
  * 목적
    * TCP는 네트워크의 기본적인 데이터 전송을 담당하는 반면, 웹소켓은 웹 애플리케이션에서 실시간 양방향 통신을 가능하게 하는 것을 목표로 함.
  * 연결방식
    * TCP는 연결 지향적이며 신뢰성 있는 통신을 제공하는 반면, 웹 소켓은 HTTP 연결을 업그레이드 하여 양방향 통신 채널을 만듬
  * 사용사례
    * TCP는 인터넷 상의 다양한 애플리케이션에서 사용되는 기본적인 프로토콜이며, 웹소켓은 주로 웹 기반 실시간 양방향 통신에 사용 됨.

### 웹소켓 프로토콜로의 업그레이드 과정
> 클라이언트와 서버간의 초기 HTTP 핸드셰이크를 통해 이루어짐.     
> 이 과정에서 클라이언트는 웹소켓 연결을 요청하고, 서버가 이를 수락함으로써 HTTP연결이 웹 소켓으로 전환 됨
1. 클라이언트에서의 웹 소켓 연결 요청
> 클라이언트는 서버에 HTTP GEP요청을 보내고, 이 요청에는 웹소켓 연결을 위한 특별한 헤더들이 포함 됨.
  * Upgrade: websocket
    * HTTP 프로토콜을 웹소켓 프로토콜로 업그레이드하고자 함을 나타냄
  * Connection: Upgrade
    * 현재의 연결을 유지하면서 프로토콜을 전환하고자 함을 나타냄
  * Sec-WebSocket-Key
    * 서버에 의해 사용되어 응답을 생성하는데 사용되는 무작위로 인코딩 된 값.
  * Sec-WebSokcet-Version
    * 클라이언트가 사용하는 웹소켓 프로토콜의 버전을 명시함
2. 서버에서의 응답 및 프로토콜 업그레이드
> 서버가 웹소켓 연결을 지원하고 클라이언트의 요청을 수락하는 경우, 다음과 같은 HTTP 응답을 보냄
  * HTTP/1.1 101 Switching Protocols
    * 서버가 웹소켓 프로토콜의 업그레이드를 확인함
  * Upgrade: websocket
    * 서버가 웹 소켓 프로토콜로의 업그레이드를 확인함.
  * Connection: Upgrade
    * 형재의 연결이 웹소켓 연결로 전환됨을 나타냄
  * Sec-WebSocket-Accept
    * 클라이언트의 Sec-WebSocket-Key헤더 값을 기반으로 생성된 값이며, 클라이언트가 서버의 응답을 확인하는데 사용
3. 웹 소켓 연결의 시작
> 위의 핸드셰이크 과정이 성공적으로 완료되면, HTTP연결은 웹소켓 연결로 업그레이드 되며,     
> 이후의 데이터 교환은 웹소켓 프로토콜을 통해 이루어짐.     
> 이 시점부터 클라이언트와 서버 간에는 실시간, 양방향 통신이 가능해짐
