# 20231231 추가 질문

토비의 스프링 책은 3버전 다루고 있는데 지금은 5버전의 시대인데 책은 여전히 의미가 크다 왜그럴까?
->기술의 문제를 풀고 접근하는 방식이 달라 지지 않음 (근본은 영원)
=>
객체지향이란?
=>
UML이란? 어떨 때 쓸까? 왜쓸까?
=>
스택 프레임이라는 말이 많이 나오는데 우리는 자바의 신에서 `Stack` 에 대해 공부했었습니다. 그 `Stack` 과 여기 나오는 스택은 같은 말일까요? 어떤 것 때문에 스택이라고 부르는걸까요?
(메소드 체인에서 나중에 호출된 메소드가 제일 먼저 리턴된다)
=>
전역 변수를 쓰면 어떤 문제?
(Thread Safe 문제)
=>
멀티 프로세스와 멀티 스레딩의 차이?
=>
T메모리 구조란?
=>
클래스와 객체의 차이?
=>
캡슐화란? 왜쓸까?
=>
예를들면 회원매니저클래스에 회원정보를 HashMap으로 들고 있는데 이걸 public으로 하게된다면 어떤 문제가 있을까?
(보안 X, 우리가 의도한대로만 프로그램을 동작하게 하기위한 장치)
=>
상속이란 ? 왜쓸까?
=>
단점은 (상위클래스와의 강결합. M*N문제 -> 컴포지션으로 해결)
=>
추상화란?
=>
로컬용 업로드 클래스/S3용 업로드를 하는 클래스
이경우 어떻게 추상화할까?? 안한다면 어떤문제가 생길수 있을까?
(추상화를 적절하게 할수록 기존 코드에 변경없이 유연하게 처리하게된다)
=>
SOLID
=>
SRP? 왜쓸까?
(유저에 레포지토리가 함께있다면?, 주문/결제가 함게 있다면?, 계산기/알림이 함꼐있다면?-> 분리함으로써 코드유지보수가 용이해지고 각부분이 서로 영향 미칠 가능성을 최소화함, 그리고 개인적으로는 중요하게 생각하는건 개념적으로 이해가 쉬워지는듯.)
=>
OCP?
=>
뭐에 오픈? 뭐에 클로즈드?
(확장에는열리고 수정에는 닫혀있어야한다)
=>
할인정책 예시를 들어보자. 케이스가 늘어날수록 기존코드가 복잡하게 변경됨.
public class DiscountCalculator {
    public double calculateDiscount(String discountType, double amount) {
        if (discountType.equals(“FIXED”)) {
            return amount - 30;
        } else if (discountType.equals(“PERCENTAGE”)) {
            return amount - amount * 0.2;
        }
        return amount;
    }
}
위의 코드를 개선해보세요
왜쓰지? (상위클래스가 구현이 추가되어도 변경되지 않고 유지된다)
=>
LSP?
(상속받은 클래스는 상위클래스의 역할을 대체 할수 있어야한다)
(다음의 경우 각각의 가로 세로를 설정한다는 상위 클래스의 역할못해 원칙 깨짐)
public class Rectangle {
    protected int width;
    protected int height;
    public void setWidth(int width) {        this.width = width;    }
    public void setHeight(int height) {        this.height = height;    }
    public int getArea() {        return width * height;    }
}
public class Square extends Rectangle {
    @Override   public void setWidth(int width) {
        super.setWidth(width); super.setHeight(width);
    }
    @Override
    public void setHeight(int height) {
        super.setWidth(height);        super.setHeight(height);
    }
}
위의 코드를 개선해보세요
ISP( Interface Segregation Principle) 어떤걸까 왜쓸까?
(자신이 필요로 하는 구체 클래스 들에만 의존하게 되므로 불필요한 코드 관리 필요 없다.)
public interface Worker {
    void work();
    void eat();
}
public class HumanWorker implements Worker {
    public void work() {        // 일하는 기능    }
    public void eat() {        // 식사하는 기능    }
}
public class RobotWorker implements Worker {
    public void work() {        // 일하는 기능    }
    public void eat() {        // 로봇은 식사 기능이 필요 없음    }
}
위의 코드를 개선해보세요
DIP 이란 무엇일까요?
(다음의경우 새로운 노티서비스가 추가되면 이메일서비스 쪽도 함꼐 수정되어야함)
public class EmailService {
    public void sendEmail(String message, String receiver) {// 이메일 전송  }
}
public class NotificationService {
    private EmailService emailService;
    public NotificationService() {  this.emailService = new EmailService();  }
    public void sendNotification(String message, String receiver) {
        emailService.sendEmail(message, receiver);
    }
}
위의 코드를 개선해보세요
어댑터 패턴은 무슨 패턴일까요?
프록시 패턴은 무슨 패턴일까요?
데코레이터 패턴은 무슨 패턴일까요?
프록시 패턴과 다른 점은 무엇일까요?
템플릿 메소드 패턴은 무슨 패턴일까요?
팩터리 메소드 패턴은 무슨 패턴일까요?
strategy 패턴은 무슨 패턴일까요?
템플릿 콜백 패턴은 무슨 패턴일까요?
- 여태까지 의존한다는 용어를 계속 사용했는데, 의존성이란 무엇일까요?
- 일반적으로 Constructor Injection을 권장하는데 그 이유가 무엇일까요?
- `@Autowired` , `@Resource` , `@Inject` 의 차이점이 무엇일까요?
- 같은 타입의 빈이 여러 개 떠있을 때 어떤 것을 사용해보면 유지보수 방면에서 좋을까요?
-------------
토비책 시작
AoP
->
IoC
->
DI
->
DI 종류
-> Field Injection, Setter Injection, Constructor Injection
-> 뭐가 가장 좋을까 왜그럴까?
@Autowired vs @RequiredArgsConstructor
->
