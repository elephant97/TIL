# 20231231 추가 질문

### 토비의 스프링 책은 3버전 다루고 있는데 지금은 5버전의 시대인데 책은 여전히 의미가 크다 왜그럴까?
* 기본원리와 개념
  * 기본적인 원리와 개념을 다룸, 기본적인 내용은 버전이 업데이트되어도 크게 변하지 않아서 스프링의 기본 원리를 이해는데 여전히 유용함
  
### 객체지향이란?
* 실세계의 개체와 개념을 모델링하여 소프트웨어 내의 상호작용하는 객체들로 표현하는 프로그래밍 패러다임
  
### UML은 무엇이며 어떨때 사용되는가?
* **UML**
  * 소프트웨어 시스템의 설계를 시각화 하고 문서화하기 위해 사용되는 표준화된 모델링 언어
* 시스템 구조 시각화
  * 시스템 구조를 표현하기 위해 클래스 다이어그램, 객체 다이어그램 등을 사용하여 시스템 내의 클래스들의 관계와 구조를 보여줌
* 행위 표현
  * UML은 시퀀스 다이어그램, 상태 다이어그램 등을 통해 시스템 내의 객체 간의 상호작용 및 객체 상태 변화를 나타내는데 유용함
* 시스템 설계 문서화
  * UML은 소프트웨어의 설계를 체계적으로 문서화하는데 사용되며, 이를 통해 개발자, 설계자 및 이해관계자 간의 의사소통을 용이하게 함
* 리팩토링 및 시스템 이해
  * 기존 시스템의 리팩토링이나 새로운 팀원이 기존 시스템을 이해하는데 UML다이어그램이 유용하게 사용 됨
    
### 스택 프레임
* **스택 프레임**
  * 함수를 호출할 때 마다 생성되는 메모리 구조를 말함
  * 스택 프레임은 각 함수 호출에 대한 정보를 담고있으며, 주로 함수의 매개변수, 지역변수, 반환 주소등을 포함함
  * 프로그램 실행 중 함수의 호출과 반환을 관리하는데 중요한 역할을 함
* **자바의 Stack**
  * 자료구조 중 하나인 스택을 말하는 것
  * 후입선출을 가진 특성을 가진 자료구조로 마지막에 추가된 요소가 가장 먼저 제거되는 특성을 가짐
* **가장 나중에 호출된 것 부터 제거되는 순서가 동일하여 스택이라고 부름**

### 전역 변수를 쓰면 어떤 문제가 있는가
* 전역 변수는 하나의 메모리에 쓰인 변수를 여러 곳에서 참조할 수 있으므로 여러개의 스레드가 동시에 해당 변수를 쓰거나 쓰는 중 읽는 작업을 하면 레이스 컨디션 문제가 발생할 수 있다.
* 이를 방지하기 위해 thread safe한 객체를 사용하여야 하거나, 읽는 행동과 쓰는 행동을 제한해야한다.

### 멀티 프로세스와 멀티 스레딩의 차이
* **멀티 프로세스**
  * 여러개의 독립적인 프로세스가 동시에 실행되는 것
  * 각 프로세스는 자신만의 메모리 공간을 가짐
  * 각 프로세스가 독립적인 메모리 공간을 가지므로, 컨텍슽 스위칭이 발생할 때 상대적으로 더 많은 시간과 자원을 소모
* **멀티 스레딩**
  * 하나의 프로세스 내부에서 여러개의 스레드가 동시에 실행되는 것
  * 프로세스 내에서 코드, 데이터, 힙 영역을 공유하며 각자의 스택을 가짐
  * 스레드들은 메모리와 자원을 공유하기 때문에 자원 사용이 효율적임
  * 메모리와 자원을 공유하기 때문에 동시성 문제가 발생할 수 있다(레이스 컨디션)
  * 프로세스보다 스레드를 생성하고 관리하는데 자원이 덜 소모되며, 컨텍스트 스위칭 비용도 낮음
  * 스레드간 통신이 간단하며 공유메모리를 통해 이루어질 수 있다 하지만 접근을 관리하기 위해 동기화 기법이 필요함
    
### T메모리 구조란?


### 클래스와 객체의 차이?
* 클래스
  * 객체를 생성하기 위한 템플릿
  * 클래스에는 속성(변수)와 행위(메서드)를 정의함
  * 객체가 가지게 될 상태와 행동을 기술함
  * 클래스 자체는 추상적인 개념으로 메모리에 직접 할당되지 않음
  * 클래스는 실체가 없고 객체를 생성하기 위한 설계도 역할을 함
* 객체
  * 클래스에 정의된 속성과 행위를 가지는 실체
  * 클래스가 메모리에 할당되어 실제로 작동할 수 있는 상태가 되면 이를 객체라고 부르며, 이 과정을 인스턴스화라고 함
  * 객체는 독립적인 상태를 가짐
  * 같은 클래스로부터 생성된 여러 객체가 있떠라도 각 객체는 서로 다른 상태를 가질 수 있음
    
### 캡슐화란 무엇이며 왜 사용되는가
* 캡슐화는 객체 지향 프로그래밍의 핵심 원칙 중 하나로, 객체의 데이터와 그 데이터를 조작하는 메서드를 하나의 단위로 묶는 것을 의미
* **사용이유**
  * 데이터 은닉
    * 캡슐화를 통해 객체 내부의 상태를 외부로부터 숨기고, 객체의 세부 구현을 외부에 노출하지 않음
    * 클래스의 내부 구현을 변경하더라도 외부에 영향을 주지 않도록 함
  * 인터페이스 제공
    * 객체는 외부와 상호작용을 위한 인터페이스(메서드)를 제공하며, 이를 통해 객체 상태를 안전하게 조작할 수 있음
  * 유지보수성 향상
    * 데이터와 메서드가 하나의 단위로 묶여있기 때문에, 코드를 이해하고 유지보수 하기가 쉬워짐
    * 캡슐화는 코드의 응집도를 높이고, 결합도를 낮추는데 기여함
  * 안정성 및 견고성 증가
    * 클래스의 내부 구현을 숨기고, 제한된 방식으로만 데이터에 접근하게 함으로써, 데이터의 오용을 방지하고 객체의 안정성과 견고성을 증가시킴
  * 재사용성과 확장성
    * 캡슐화된 클래스는 다른 프로그램이나 모듈에서도 재사용 하기 쉬움
    * 클래스의 내부 구현을 변경하거나 확장하는 것이 외부 코드에 영향을 미치지 않으므로 확장성도 좋아짐

### 상속이란 무엇이며, 왜 사용되는가
* 한 클래스의 속성과 메서드를 다른 클래스가 받아서 사용할 수 있게 하는 메커니즘
* **사용이유**
  * 코드 재사용성
    * 상속을 통해 이미 작성된 클래스의 코드를 재 사용할 수 있음
    * 새로운 클래스를 작성할 때 기존 클래스의 속성과 메서드를 상속받아 중복된 코드의 작성을 피할 수 있음
  * 유지보수의 용이성
    * 공통된 기능을 부모 클래스에 구현함으로 써 여러 자식 클래스에서 이 기능을 공유할 수 있음
    * 코드 중복을 중리고 유지보수를 용이하게 만듬
    * 부모클래스에서 버그를 수정하면 이 수정사항이 모든 자식클래스에 자동으로 적용 됨
  * 확장성
    * 기존 클래스의 기능을 상속받아 새로운 기능을 추가함으로써, 기존 코드으 변경 없이 새로운 기능 확장 가능
  * 계층구조
    * 클래스 간에 계층적 관계를 형성함으로써, 복잡한 시스템을 이해하고 관리하기 쉬워짐
   * 다형성
     * 부모클래스 타입의 참조 변수가 자식 클래스의 인스턴스를 참조할 수 있게 하여, 같은 인터페이스 아래에서 다양한 구현을 제공할 수 있어 프로그램의 유성과 확장성을 높여줌
* **단점**
  * 강한 결합
    * 부모클래스와 자식 클래스 간에 강한 결합 관계를 만들어 부모 클래스의 변경이 자식클래스에 영향을 미침
  * 클래스 폭발
    * 상속을 과도하게 사용할 경우 하위클래스가 많이 생겨 관리와 이해를 어렵게 만듬
  * 부적절한 상속
    * 상속의 관계가 명확하지 않을 때 상속하면 설계가 부적절해 질 수 있음
  * 유연성 감소
    * 상속은 계층 구조를 만들어내며, 이 구조 내에서의 이동과 변경이 어렵게 될 수 있음
  * 재사용성 감소
    * 불필요한 기능까지 포함되므로 불필요한 코드의 증가를 초래할 수 있음

### 추상화란?
* 복잡한 시스템을 간단한 개념으로 변환하는 과정으로, 필수적인 특성과 행동만을 강조하여 클래스로 표현하는 것을 통해 효율적인 설계와 개발을 가능하게 함
* 복잡성 감추기
  * 추상화를 통해 복잡한 내부 구현을 숨기고 사용자에게 필요한 정보를 제공함
* 핵심 개념 강조
  * 추상화는 필수적이고 핵심적인 부분을 강조하여, 복잡한 세부 사항으로부터 주의를 끌어내는 데 도움을 줌
  * 이를 통해 개발자는 시스템의 핵심 기능과 인터페이스에 집중할 수 있음
* 인터페이스와 구현 분리
  * 추상화는 사용자가 시스템을 사용하는 방법과 실제로 작동하는 방식을 분리함
  * 이로 인해 시스템의 구현 방식이 변경되더라도 사용자 인터페이스에는 영향을 미치지 않음
* 재사용성과 유연성 향상
  * 추상화된 구성 요소는 더 넓은 범위의 문제에 적용될 수 있으며, 특정 상황이나 응용 프로그램에 국한되지 않음
  * 코드의 재사용성과 시스템의 유연성을 증가시킴
 * 계층적 사고
   * 시스템을 다양한 수준의 추상화로 나누어 생각할 수 있게 하며, 복잡한 문제를 해결하는데 도움을 줌

### SOLID
* 객체지향 프로그래밍과 설계에서 좋은 코드를 작성하기 위한 다섯가지 핵심 원칙
* 소프트웨어의 유지보수성, 유연성, 확장성을 향상시키는데 중점을 둠

### 어댑터 패턴은 무슨 패턴일까요?
### 프록시 패턴은 무슨 패턴일까요?
### 데코레이터 패턴은 무슨 패턴일까요?
### 프록시 패턴과 다른 점은 무엇일까요?
### 템플릿 메소드 패턴은 무슨 패턴일까요?
### 팩터리 메소드 패턴은 무슨 패턴일까요?
### strategy 패턴은 무슨 패턴일까요?
### 템플릿 콜백 패턴은 무슨 패턴일까요?

### 의존성이란?
* 한 요소가 다른 요소에 의존하는 관계를 말함
* 다른 요소의 기능, 데이터, 객체 등을 사용하거나 필요로 할 때 의존성 발생

### `@Autowired` , `@Resource` , `@Inject` 의 차이점이 무엇일까요?
1. @Autowired (스프링 특화)
  * 스프링 프레임워크가 제공하는 애노테이션.
  * 타입(Type)에 기반하여 의존성을 자동으로 주입.
  * 같은 타입의 빈이 여러 개 있는 경우, 필드 이름(또는 @Qualifier 애노테이션)을 기준으로 의존성을 구별.
  * 필드, 생성자, 세터 메서드에 사용할 수 있으며, 생성자 주입에서는 @Autowired 생략이 가능.
  * @Autowired에 required 속성을 false로 설정하면, 해당 빈이 없는 경우에도 애플리케이션이 정상적으로 시작.
2. @Resource (Java EE)
  * Java EE에서 제공하는 애노테이션.
  * 기본적으로 이름(Name)에 기반하여 의존성을 주입.
  * 이름으로 적합한 빈을 찾지 못할 경우, 타입으로 대체하여 의존성을 주입.
  * @Resource는 name, type, mappedName 등의 속성을 가질 수 있으며, 필드와 세터 메서드에 사용할 수 있음.
  * 스프링 프레임워크에서도 사용할 수 있지만, 주로 Java EE 표준을 따르는 환경에서 사용됨.
3. @Inject (JSR-330)
  * Java 표준 (JSR-330)의 일부로 제공되는 애노테이션입.
  * @Autowired와 유사하게 타입에 기반하여 의존성을 주입.
  * @Autowired와는 달리 required 속성을 지원하지 않음.
  * 즉, 필요한 의존성이 없으면 실패.
  * @Named 애노테이션을 사용하여 의존성을 명시적으로 지정할 수 있음.
  * 스프링과 Java EE 모두에서 사용할 수 있으며, 플랫폼에 종속적이지 않은 표준 방식을 제공

### AoP
* 관심사와 횡단 관심사의 분리
  
### IoC
* 제어 역전의 원칙
* 프로그램의 흐름을 개발자가 아닌 프레임워크나 라이브러리와 같은 외부 시스템이 관리하도록 하는 개념

### DI
* IoC의 하나로 의존성을 주입하는 것
* 의존성 주입에서 객체의 의존성은 외부에서 주입되며, 이를 통해 객체 간의 결합도가 낮아짐
* 객체의 필요한 의존성을 직접 생성하지 않고 외부에서 제공받음
  
### DI 종류
* Field Injection
  * 장점
    > 간결하게 작성이 가능함
  * 단점
    > 단위 테스트 시 의존성을 수동으로 주입해야하기 때문에 테스트가 어려움    
    > 의존성이 명확하지 않아 코드의 이해도가 낮아질 수 있음
* Setter Injection
  * 장점
    > 객체 생성 후 의존성을 변경할 수 있음
  * 단점
    > 세터 메소드를 호출하기 전까지는 객체가 불안전한 상태임    
    > 오버라이딩될 경우 의존성 주입에 문제가 생길 수 있음
* Constructor Injection
  * 장점
    > 완전한 객체를 보장함
    > 한번 설정된 의존성은 변경할 수 없어 객체의 불변성을 보장함     
    > 단위 테스트 시 필요한 의존성을 쉽게 제공할 수 있음
  * 단점
    > 여러 의존성을 가진 클래스는 복잡한 생성자를 가질 수 있음     
    > 생성자 주입을 사용할 때 순환 의존성이 있으면 해결하기 어려울 수 있음 
### @Autowired vs @RequiredArgsConstructor
* Autowired는 스프링에서 제공하는 생성자 주입 방식
* RequiredArgsContructor는 롬복에서제공하는 final필드에 붙은 필드 또는 @NonNull이 붙은 필드에 대한 생성자를 자동으로 생성해줌
