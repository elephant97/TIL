# 20231231 추가 질문

### 토비의 스프링 책은 3버전 다루고 있는데 지금은 5버전의 시대인데 책은 여전히 의미가 크다 왜그럴까?
* 기본원리와 개념
  * 기본적인 원리와 개념을 다룸, 기본적인 내용은 버전이 업데이트되어도 크게 변하지 않아서 스프링의 기본 원리를 이해는데 여전히 유용함
  
### 객체지향이란?
* 실세계의 개체와 개념을 모델링하여 소프트웨어 내의 상호작용하는 객체들로 표현하는 프로그래밍 패러다임
  
### UML은 무엇이며 어떨때 사용되는가?
* **UML**
  * 소프트웨어 시스템의 설계를 시각화 하고 문서화하기 위해 사용되는 표준화된 모델링 언어
* 시스템 구조 시각화
  * 시스템 구조를 표현하기 위해 클래스 다이어그램, 객체 다이어그램 등을 사용하여 시스템 내의 클래스들의 관계와 구조를 보여줌
* 행위 표현
  * UML은 시퀀스 다이어그램, 상태 다이어그램 등을 통해 시스템 내의 객체 간의 상호작용 및 객체 상태 변화를 나타내는데 유용함
* 시스템 설계 문서화
  * UML은 소프트웨어의 설계를 체계적으로 문서화하는데 사용되며, 이를 통해 개발자, 설계자 및 이해관계자 간의 의사소통을 용이하게 함
* 리팩토링 및 시스템 이해
  * 기존 시스템의 리팩토링이나 새로운 팀원이 기존 시스템을 이해하는데 UML다이어그램이 유용하게 사용 됨
    
### 스택 프레임
* **스택 프레임**
  * 함수를 호출할 때 마다 생성되는 메모리 구조를 말함
  * 스택 프레임은 각 함수 호출에 대한 정보를 담고있으며, 주로 함수의 매개변수, 지역변수, 반환 주소등을 포함함
  * 프로그램 실행 중 함수의 호출과 반환을 관리하는데 중요한 역할을 함
* **자바의 Stack**
  * 자료구조 중 하나인 스택을 말하는 것
  * 후입선출을 가진 특성을 가진 자료구조로 마지막에 추가된 요소가 가장 먼저 제거되는 특성을 가짐
* **가장 나중에 호출된 것 부터 제거되는 순서가 동일하여 스택이라고 부름**

### 전역 변수를 쓰면 어떤 문제가 있는가
* 전역 변수는 하나의 메모리에 쓰인 변수를 여러 곳에서 참조할 수 있으므로 여러개의 스레드가 동시에 해당 변수를 쓰거나 쓰는 중 읽는 작업을 하면 레이스 컨디션 문제가 발생할 수 있다.
* 이를 방지하기 위해 thread safe한 객체를 사용하여야 하거나, 읽는 행동과 쓰는 행동을 제한해야한다.

### 멀티 프로세스와 멀티 스레딩의 차이
* **멀티 프로세스**
  * 여러개의 독립적인 프로세스가 동시에 실행되는 것
  * 각 프로세스는 자신만의 메모리 공간을 가짐
  * 각 프로세스가 독립적인 메모리 공간을 가지므로, 컨텍슽 스위칭이 발생할 때 상대적으로 더 많은 시간과 자원을 소모
* **멀티 스레딩**
  * 하나의 프로세스 내부에서 여러개의 스레드가 동시에 실행되는 것
  * 프로세스 내에서 코드, 데이터, 힙 영역을 공유하며 각자의 스택을 가짐
  * 스레드들은 메모리와 자원을 공유하기 때문에 자원 사용이 효율적임
  * 메모리와 자원을 공유하기 때문에 동시성 문제가 발생할 수 있다(레이스 컨디션)
  * 프로세스보다 스레드를 생성하고 관리하는데 자원이 덜 소모되며, 컨텍스트 스위칭 비용도 낮음
  * 스레드간 통신이 간단하며 공유메모리를 통해 이루어질 수 있다 하지만 접근을 관리하기 위해 동기화 기법이 필요함
    
### T메모리 구조란?


### 클래스와 객체의 차이?
* 클래스
  * 객체를 생성하기 위한 템플릿
  * 클래스에는 속성(변수)와 행위(메서드)를 정의함
  * 객체가 가지게 될 상태와 행동을 기술함
  * 클래스 자체는 추상적인 개념으로 메모리에 직접 할당되지 않음
  * 클래스는 실체가 없고 객체를 생성하기 위한 설계도 역할을 함
* 객체
  * 클래스에 정의된 속성과 행위를 가지는 실체
  * 클래스가 메모리에 할당되어 실제로 작동할 수 있는 상태가 되면 이를 객체라고 부르며, 이 과정을 인스턴스화라고 함
  * 객체는 독립적인 상태를 가짐
  * 같은 클래스로부터 생성된 여러 객체가 있떠라도 각 객체는 서로 다른 상태를 가질 수 있음
    
### 캡슐화란 무엇이며 왜 사용되는가
* 캡슐화는 객체 지향 프로그래밍의 핵심 원칙 중 하나로, 객체의 데이터와 그 데이터를 조작하는 메서드를 하나의 단위로 묶는 것을 의미
* 사용이유
  * 데이터 은닉
    * 캡슐화를 통해 객체 내부의 상태를 외부로부터 숨기고, 객체의 세부 구현을 외부에 노출하지 않음
    * 클래스의 내부 구현을 변경하더라도 외부에 영향을 주지 않도록 함
  * 인터페이스 제공
    * 객체는 외부와 상호작용을 위한 인터페이스(메서드)를 제공하며, 이를 통해 객체 상태를 안전하게 조작할 수 있음
  * 유지보수성 향상
    * 데이터와 메서드가 하나의 단위로 묶여있기 때문에, 코드를 이해하고 유지보수 하기가 쉬워짐
    * 캡슐화는 코드의 응집도를 높이고, 결합도를 낮추는데 기여함
  * 안정성 및 견고성 증가
    * 클래스의 내부 구현을 숨기고, 제한된 방식으로만 데이터에 접근하게 함으로써, 데이터의 오용을 방지하고 객체의 안정성과 견고성을 증가시킴
  * 재사용성과 확장성
    * 캡슐화된 클래스는 다른 프로그램이나 모듈에서도 재사용 하기 쉬움
    * 클래스의 내부 구현을 변경하거나 확장하는 것이 외부 코드에 영향을 미치지 않으므로 확장성도 좋아짐
       
### 예를들면 회원매니저클래스에 회원정보를 HashMap으로 들고 있는데 이걸 public으로 하게된다면 어떤 문제가 있을까?
(보안 X, 우리가 의도한대로만 프로그램을 동작하게 하기위한 장치)
=>
### 상속이란 ? 왜쓸까?
=>
### 단점은 (상위클래스와의 강결합. M*N문제 -> 컴포지션으로 해결)
=>
### 추상화란?
=>
### 로컬용 업로드 클래스/S3용 업로드를 하는 클래스이경우 어떻게 추상화할까?? 안한다면 어떤문제가 생길수 있을까?
(추상화를 적절하게 할수록 기존 코드에 변경없이 유연하게 처리하게된다)
=>
### SOLID
=>
### SRP? 왜쓸까?
(유저에 레포지토리가 함께있다면?, 주문/결제가 함게 있다면?, 계산기/알림이 함꼐있다면?-> 분리함으로써 코드유지보수가 용이해지고 각부분이 서로 영향 미칠 가능성을 최소화함, 그리고 개인적으로는 중요하게 생각하는건 개념적으로 이해가 쉬워지는듯.)
=>
### OCP?
=>
### 뭐에 오픈? 뭐에 클로즈드?
(확장에는열리고 수정에는 닫혀있어야한다)
=>
할인정책 예시를 들어보자. 케이스가 늘어날수록 기존코드가 복잡하게 변경됨.
```java
public class DiscountCalculator {
    public double calculateDiscount(String discountType, double amount) {
        if (discountType.equals(“FIXED”)) {
            return amount - 30;
        } else if (discountType.equals(“PERCENTAGE”)) {
            return amount - amount * 0.2;
        }
        return amount;
    }
}
```
위의 코드를 개선해보세요
### 왜쓰지? (상위클래스가 구현이 추가되어도 변경되지 않고 유지된다)
=>
### LSP?
(상속받은 클래스는 상위클래스의 역할을 대체 할수 있어야한다)
(다음의 경우 각각의 가로 세로를 설정한다는 상위 클래스의 역할못해 원칙 깨짐)
```java
public class Rectangle {
    protected int width;
    protected int height;
    public void setWidth(int width) {        this.width = width;    }
    public void setHeight(int height) {        this.height = height;    }
    public int getArea() {        return width * height;    }
}
public class Square extends Rectangle {
    @Override   public void setWidth(int width) {
        super.setWidth(width); super.setHeight(width);
    }
    @Override
    public void setHeight(int height) {
        super.setWidth(height);        super.setHeight(height);
    }
}
```
위의 코드를 개선해보세요
### ISP( Interface Segregation Principle) 어떤걸까 왜쓸까?
(자신이 필요로 하는 구체 클래스 들에만 의존하게 되므로 불필요한 코드 관리 필요 없다.)
```java
public interface Worker {
    void work();
    void eat();
}
public class HumanWorker implements Worker {
    public void work() {        // 일하는 기능    }
    public void eat() {        // 식사하는 기능    }
}
public class RobotWorker implements Worker {
    public void work() {        // 일하는 기능    }
    public void eat() {        // 로봇은 식사 기능이 필요 없음    }
}
```
위의 코드를 개선해보세요
### DIP 이란 무엇일까요?
(다음의경우 새로운 노티서비스가 추가되면 이메일서비스 쪽도 함꼐 수정되어야함)
```java
public class EmailService {
    public void sendEmail(String message, String receiver) {// 이메일 전송  }
}
public class NotificationService {
    private EmailService emailService;
    public NotificationService() {  this.emailService = new EmailService();  }
    public void sendNotification(String message, String receiver) {
        emailService.sendEmail(message, receiver);
    }
}
```
위의 코드를 개선해보세요
### 어댑터 패턴은 무슨 패턴일까요?
### 프록시 패턴은 무슨 패턴일까요?
### 데코레이터 패턴은 무슨 패턴일까요?
### 프록시 패턴과 다른 점은 무엇일까요?
### 템플릿 메소드 패턴은 무슨 패턴일까요?
### 팩터리 메소드 패턴은 무슨 패턴일까요?
### strategy 패턴은 무슨 패턴일까요?
### 템플릿 콜백 패턴은 무슨 패턴일까요?
### 여태까지 의존한다는 용어를 계속 사용했는데, 의존성이란 무엇일까요?
### 일반적으로 Constructor Injection을 권장하는데 그 이유가 무엇일까요?
### `@Autowired` , `@Resource` , `@Inject` 의 차이점이 무엇일까요?
### 같은 타입의 빈이 여러 개 떠있을 때 어떤 것을 사용해보면 유지보수 방면에서 좋을까요?
-------------
토비책 시작
### AoP
->
### IoC
->
### DI
->
### DI 종류
-> Field Injection, Setter Injection, Constructor Injection
-> 뭐가 가장 좋을까 왜그럴까?
### @Autowired vs @RequiredArgsConstructor
->
