# 20231203(2회차) 멘토링 내용 정리📒
==> 다시 볼 부분은 💡로 표시

### 메모리 영역을 나눈 이유
* 다양한 프로그램의 요구 사항을 충족시키기 위해 설계됨.
* 효율성, 안정성, 보안, 유지보수성 등 여러 가지 이유로 이루어져 있음.

1. 가상 머신 (JVM) 구조   
  - Java는 Java 가상 머신 (JVM) 위에서 실행 됨.
  - JVM은 스택, 힙, 메소드 영역 등 다양한 메모리 영역을 가지고 있음
  - 이러한 영역들은 Java 프로그램이 효과적으로 실행될 수 있도록 조율됨.
2. 자동 메모리 관리   
  - Java에서는 가비지 컬렉션(Garbage Collection)을 통해 동적으로 할당된 객체의 메모리를 자동으로 관리함.
  - 힙 영역은 이 가비지 컬렉션에 의해 동적으로 생성된 객체들이 저장되며, 더 이상 사용되지 않는 객체들은 자동으로 제거됩니다.
3. 스레드 안전성
  - Java는 멀티스레드 환경에서 안전한 프로그래밍을 지향.
  - 각 스레드는 독립된 스택을 가지고 있어서 스레드 간의 충돌을 방지하고, 스택 프레임은 메소드 호출과 관련된 지역 변수를 안전하게 저장됨.
4. 안전성 및 보안
  - Java의 메모리 관리는 안전성과 보안성을 강화함.
  - JVM은 메모리 경계를 갖고, 배열의 인덱스를 체크하거나 널 포인터 역참조를 방지함으로써 프로그램의 안정성을 보장합니다.
5. 플랫폼 독립성
  - Java는 Write Once, Run Anywhere (WORA)를 지향.
  - 메모리 구조를 일정하게 유지하면서 플랫폼 독립성을 확보하고, Java 프로그램이 어떤 환경에서든지 일관된 방식으로 동작할 수 있게 함.
6. 동적 로딩 및 동적 링킹 
  - Java에서는 클래스 로딩이 동적으로 이루어지며, 클래스의 코드는 런타임에 필요한 시점에 로딩 됨.
  - 이러한 특성은 메소드 영역에 해당하며, 동적 로딩 및 동적 링킹을 가능케 합니다.

> Java에서의 메모리 구조는 이러한 특징들을 반영하여 설계되었으며, 자동 메모리 관리와 스레드 안전성을 통해 개발자가 효율적으로 안정된 프로그램을 작성할 수 있도록 지원함

### 각 메모리 영역
1. Stack 영역
  - 목적: 지역 변수 및 메소드 호출과 관련된 데이터를 저장하는데 사용됨. **함수도 이곳에 저장 됨**
  - 특징: 스택은 후입선출(Last-In-First-Out, LIFO) 구조로 동작.    
         메소드가 호출될 때마다 스택에 프레임이 추가되고, 메소드가 반환될 때 프레임이 제거 됨.   
         이러한 특성으로 인해 스택은 간단하고 빠른 데이터 액세스를 제공.
2. Heap 영역
  - 목적: 동적으로 할당된 객체 및 데이터를 저장하는데 사용됨.   
  - 특징: 힙은 메모리를 동적으로 할당하고 해제할 수 있는 영역으로, 데이터의 크기와 생존 기간이 동적으로 결정됨.   
         개발자가 직접 메모리를 할당하고 해제할 수 있으며, 이는 유연성을 제공함.   
         메모리 누수와 같은 문제에 주의해야 함.   
3. 메서드, Static (또는 Global) 영역
  - 목적: 전역 변수, 정적 변수 및 상수를 저장하는데 사용됨. ⭐ 여기에 enum도 저장 됨 ⭐
  - 특징: 정적 변수와 전역 변수는 프로그램이 시작될 때 할당되고 프로그램이 종료될 때까지 존재하는데, 이들은 Static 영역에 저장됨.   
         상수도 마찬가지로 프로그램이 실행되는 동안 메모리에 상주함.

### Min Heap / Max Heap
> Max Heap과 Min Heap은 모두 힙(Heap)이라는 자료 구조의 특별한 형태를 나타냄.   
> 힙은 완전 이진 트리(Complete Binary Tree)의 일종으로서, 각 노드의 값이 그 자식 노드의 값보다 크거나(Max Heap) 또는 작거나 같은(Min Heap) 특성을 가지고 있습니다.
  * **Max Heap (최대 힙)**
    - 특징
      - 각 노드의 값이 자식 노드의 값보다 크거나 같다.
      - 루트 노드에는 트리 내에서 가장 큰 값이 위치.
    - 힙 속성
      - 부모 노드의 값은 항상 자식 노드의 값보다 크거나 같다.
      - 완전 이진 트리의 형태를 가짐.
    - 활용
      - 최대 값에 빠르게 접근할 수 있는 우선순위 큐를 구현할 때 사용 됨.
      - 힙 정렬(Heap Sort) 알고리즘에 사용됨.
  * **Min Heap (최소 힙)**
    - 특징
      - 각 노드의 값이 자식 노드의 값보다 작거나 같음.
      - 루트 노드에는 트리 내에서 가장 작은 값이 위치.
    - 힙 속성
      - 부모 노드의 값은 항상 자식 노드의 값보다 작거나 같음.
      - 완전 이진 트리의 형태를 가짐.
    - 활용
      - 최소 값에 빠르게 접근할 수 있는 우선순위 큐를 구현할 때 사용됩니다.
      - 다익스트라 알고리즘과 같은 그래프 알고리즘에서 최소 거리를 찾을 때 활용됩니다.

  * 힙의 연산
      - 삽입 (Insertion): 새로운 요소를 힙에 추가하고 힙 속성을 유지.
      - 삭제 (Deletion): 루트 노드를 삭제하고 힙 속성을 다시 조정.
      - 힙 구축 (Heapify): 주어진 배열을 힙 속성을 가진 힙으로 변환.   
      *최대 힙과 최소 힙은 각각 다양한 응용 분야에서 효과적으로 사용되며, 힙은 정렬, 우선순위 큐, 그래프 알고리즘 등 다양한 알고리즘에서 기본적인 자료 구조로 활용*

### 순수 함수 (Pure Function) 와 비순수 함수 (Impure Function)
* **순수함수 (Pure Function)**
  * 결정론적 (Deterministic)
    * 동일한 입력에 대해 항상 동일한 출력을 생성.
    * 즉, 함수에 동일한 인자를 전달하면 항상 동일한 결과가 나옴.
  * 부작용이 없음 (No Side Effects)
    * 함수의 실행이 외부 상태에 영향을 미치지 않음.
    * 즉, 함수가 호출될 때 외부 변수를 변경하거나 입출력 작업을 수행하지 않음.
  > 순수 함수는 이러한 특징으로 인해 예측 가능하고 테스트하기 쉬우며, 코드의 이해와 유지보수를 용이하게 함.
* **비순수 함수 (Impure Function)**
  > 비순수 함수는 순수함수의 특징 중 하나 이상을 어길 수 있다.
  > 주로 부작용이 있는 함수로, 외부 상태를 변경하거나 입출력 작업을 수행할 수 있다.
  > 예를 들어, 전역 변수를 수정하거나 파일을 읽거나 쓰는 작업이 있을 수 있다.

<br>

* **차이점 및 중요성**
  * 예측 가능성과 테스트 용이성
    * 순수 함수는 입력이 같으면 항상 같은 출력을 생성하기 때문에 예측 가능하고 테스트하기 쉬움.
    * 비순수 함수는 외부 상태에 의해 결과가 영향을 받기 때문에 테스트가 어려울 수 있음.
  * 병렬성과 안정성
    * 순수 함수는 동시에 여러 호출이 이루어져도 안전하게 동작함.
    * 비순수 함수는 외부 상태를 변경할 수 있기 때문에 동시에 여러 호출이 이루어지면 예상치 못한 동작이 발생할 수 있음.
  * 코드의 이해와 유지보수 용이성
    * 순수 함수는 함수의 동작이 함수 내부에 포함되어 있으며 외부 상태에 의존하지 않기 때문에 코드의 이해와 유지보수가 쉬움.
    * 비순수 함수는 외부 상태에 의존하거나 외부 상태를 변경하기 때문에 코드의 이해와 유지보수가 어려울 수 있음.   
> 함수형 프로그래밍에서는 순수 함수를 선호하며, 이는 코드의 안정성, 예측 가능성, 테스트 용이성을 높이고 병렬성을 강화하기 위한 중요한 개념 중 하나입니다.

### Enum 
* 사용 이유
  * 리팩토링, 유지보수에 좋고 가독성이 좋음

### Enum은 == 비교가 가능한가?
  * **enum 타입의 값은 == 연산자를 사용하여 비교할 수 있음. 이는 enum이 열거 상수를 나타내는 고정된 값이기 때문.**
  * enum은 열거형 상수를 나타내는 특별한 클래스로, 각 상수는 해당 enum 타입의 유일한 인스턴스이다.
  * 따라서 == 연산자는 객체의 참조를 비교하게 되는데, enum의 경우 동일한 상수 값에 대해 동일한 인스턴스를 사용하므로 == 비교가 가능.

### interface
* 인터페이스를 사용하는 주된 이유 중 하나는 다양한 클래스에서 동일한 메소드 시그니처를 갖는 메소드들을 구현하도록 하는 것.
* 이것은 다형성을 촉진하고 코드의 재사용성을 높이는 데 도움이 됨
* 함수마다 하는 일이 다 다를 때, 각 함수에 해당하는 메소드를 인터페이스에서 정의하고, 각 클래스에서는 해당 인터페이스를 구현하여 각자의 동작을 정의.
* 이는 다양한 클래스가 동일한 인터페이스를 구현할 수 있으며, 클라이언트 코드에서는 해당 인터페이스의 메소드를 호출함으로써 다양한 구현을 사용할 수 있게 됨.
```java
//예시코드
class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍");
    }
}

class Cat implements Animal {
    @Override
    public void makeSound() {
        System.out.println("야옹");
    }
}

class Bird implements Animal {
    @Override
    public void makeSound() {
        System.out.println("짹짹");
    }
}
```
### abstract와 interface의 차이 점
* 다중 상속
  * interface는 다중 상속이 가능하며, abstract는 단일상속만 가능함
* 생성자
  * interface는 생성자를 가질수 있으나, abstract는 생성자를 가질 수 없음
* 변수
  * interface는 상수(static, final) 만을 가질 수 있으나, abstract는 일반변수 일 수 있음
* 접근제어자
  * interface의 메서드는 기본적으로 public이어야 함 abstract는 다양한 접근 제어자를 가질 수 있음. 

<br>

- Interface
    - 다중 상속이 필요하거나, 클래스의 일반적 행동을 명시적으로 정의하고자 할 때 사용.
    - 서로 다른 클래스들 간에 공통된 행동을 정의하는데 유용.
- Abstract Class
    - 코드를 공유하고 확장하기 위해 일반 메소드나 필드가 필요할 때 사용.
    - 생성자가 필요하거나, 서로 다른 클래스들 간에 코드를 공유하는 목적으로 사용.

### 💡Final 상수는 값을 변경할 수 있나?
* 클래스 final
  * 상속을 해줄 수 없다
  * 더이상 확장하면 안되느 ㄴ클래스
  * 상속받아 내용을 변경하면 안되는 클래스에 사용
* 메소드 final
  * overriding 할 수 없다
* 변수  final
  * 값을 더이상 바꿀 수 없음
  * **💡인스턴수 변수와 클래스 변수 선언 시 final 사용하면 반드시 초기화 해야함**
  * **💡지역변수와 매개변수는 선언 시 초기화 안해도 된다**
  * **💡참조 변수의 경우, 두번 이상 값을 할당하거나 새로 생성자를 사용하여 초기화 할 수 없으나, 참조변수 내부의 값은 변경 가능 안의 변수가 final은 아니기 때문**

### 만일 try-catch문에서 예외 발생하여 catch를 타고, catch 내부에 return이 되어있으면 final은 실행될까?
* 실행 됨 final은 반드시 무조건 실행되며, return 전에 실행 된다.

### 정규표현식이 빠른 이유?
* 컴파일된 형태로 패턴을 저장
  * 대부분의 정규표현식 엔진은 패턴을 미리 컴파일하여 내부적인 구조로 변환.
  * 이렇게 컴파일된 형태로 패턴을 저장하면 같은 패턴을 여러 번 사용할 때 재컴파일을 하지 않아도 되므로 속도가 향상됨.
* 최적화된 검색 알고리즘
  * 정규표현식 엔진은 최적화된 검색 알고리즘을 사용하여 입력 문자열을 효율적으로 조사함.
  * 이러한 알고리즘들은 패턴의 구조에 따라 검색 속도를 최적화하도록 설계되어 있다.
* 비트 연산 및 상태 기계 활용
  > 상태 기계(State Machine)는 동작의 다양한 상태를 나타내는 추상적인 모델
  * 일부 정규표현식 엔진은 패턴을 상태 기계로 변환하고 비트 연산을 사용하여 문자열을 검색.
  * 이는 매우 효율적인 방법 중 하나로, 검색 속도를 높일 수 있다.
* 입력 문자열을 미리 처리
  * 일부 엔진은 입력 문자열을 미리 처리하여 특정 패턴에 대한 검색 속도를 향상.
  * 예를 들어, Boyer-Moore 알고리즘과 같은 문자열 검색 알고리즘을 사용하여 미리 처리하는 경우가 있음.
* 비트셋과 오토마타 사용
  * 정규표현식 엔진은 비트셋(bitset)이나 오토마타와 같은 자료구조를 사용하여 패턴을 효율적으로 관리하고 검색.
* 컴파일된 코드로 구현
  * 일부 정규표현식 엔진은 고도로 최적화된 컴파일된 코드를 사용하여 검색을 수행.
  * 이는 일반적인 문자열 처리보다 훨씬 효율적일 수 있습니다.
> 정규표현식의 성능은 패턴의 복잡성, 입력 문자열의 크기, 엔진의 구현 등에 따라 다를 수 있음.   
> 그러나 위에서 언급한 이유들로 인해 정규표현식은 많은 상황에서 빠른 검색 속도를 제공할 수 있다.

### string literal과 String class의 차이?
* String literal -> "string"
  * 문자열 리터럴은 constant pool에 저장 됨
  * 중복된 문자열을 피하기 위한 메모리 최적화를 제공
  * 메모리를 절약하고 문자열 비교를 빠르게 만들어 줌
* String class
  * constant 풀에 있는지의 여부와 상관 없이 새로운 객체가 만들어짐

### clone() 메소드는 shallow copy일까 deep copy일까?
* clone()메소드는 기본적으로 shallow copy를 제공한다.
* deep copy가 필요한 경우 적절하게 오버라이딩하여 deep copy 로직을 구현해야 한다.

### 💡리플렉션(Reflection)
> 리플렉션(Reflection)은 프로그램이 자신의 구조를 분석하고 수정할 수 있는 능력을 가리키는 용어.
> 리플렉션을 통해 프로그램은 실행 중에 클래스의 정보를 검사하고, 객체의 속성과 메소드에 접근할 수 있습니다.
> 이는 동적으로 클래스를 로드하거나, 객체를 생성하고, 메소드를 호출하는 등의 작업을 수행하는 데 사용됩니다.
* Java에서 리플렉션은 java.lang.reflect 패키지를 통해 제공.
* 이 패키지에는 Class, Method, Field, Constructor 등과 같은 클래스들이 포함되어 있음.
* **주요한 리플렉션 기능**
  - Class 정보 얻기
    - Class 클래스를 사용하여 특정 클래스의 메타데이터를 얻을 수 있습니다. 클래스의 이름, 필드, 메소드, 생성자 등에 대한 정보를 동적으로 얻을 수 있습니다.
  - 인스턴스 생성
    - Class 객체를 통해 클래스의 인스턴스를 동적으로 생성할 수 있습니다.
  - 필드 접근
    - Field 클래스를 사용하여 클래스의 필드에 동적으로 접근할 수 있습니다.
    - 값을 읽거나 쓸 수 있습니다.
  - 메소드 호출
    - Method 클래스를 사용하여 클래스의 메소드를 동적으로 호출할 수 있습니다.
  - 생성자 호출
    - Constructor 클래스를 사용하여 클래스의 생성자를 동적으로 호출하고 인스턴스를 생성할 수 있습니다.
> 리플렉션은 일반적으로 특정 클래스의 이름을 동적으로 전달하거나, 알려진 클래스의 메타데이터를 동적으로 조사할 때 유용합니다.
> 하지만 리플렉션을 남용하면 성능 저하와 코드 가독성 감소 등의 문제가 발생할 수 있으므로 신중하게 사용해야 합니다.
```java
//예시
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ReflectionExample {
    private String name;
    public int age;

    public ReflectionExample(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void sayHello() {
        System.out.println("Hello, " + name + "!");
    }

    public static void main(String[] args) throws Exception {
        // 클래스 이름을 사용하여 Class 객체 획득
        Class<?> clazz = ReflectionExample.class;

        // 클래스의 필드 정보 얻기
        Field[] fields = clazz.getDeclaredFields();
        System.out.println("Fields:");
        for (Field field : fields) {
            System.out.println("Name: " + field.getName() + ", Type: " + field.getType());
        }

        // 클래스의 메소드 정보 얻기
        Method[] methods = clazz.getDeclaredMethods();
        System.out.println("\nMethods:");
        for (Method method : methods) {
            System.out.println("Name: " + method.getName() + ", Return Type: " + method.getReturnType());
        }

        // 클래스의 생성자 정보 얻기
        System.out.println("\nConstructors:");
        Constructor<?>[] constructors = clazz.getDeclaredConstructors();
        for (Constructor<?> constructor : constructors) {
            System.out.println("Name: " + constructor.getName());
        }

        // 클래스의 인스턴스 생성 및 메소드 호출
        Object instance = clazz.getDeclaredConstructor(String.class, int.class).newInstance("John", 25);
        Method sayHelloMethod = clazz.getDeclaredMethod("sayHello");
        sayHelloMethod.invoke(instance);
    }
}
```
