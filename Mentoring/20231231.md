# 20231231(회차) 멘토링 내용 정리📒

### 슬라이딩 윈도우
> tcp에서 수신자가 데이터를 잘 받지 못하면 데이터 전송속도를 늦추는데 그 떄 사용하는 방식
* **창의 크기를 크게 해서 (필요에 따라서는 작게) 여러 패킷을 논리적인 하나의 패킷으로 묶어서 처리를 하는 방식**
* 데이터를 전송하기 위한 가상의 컨테이너 공간
* MTU : 한번에 보낼 수 있는 패킷의 크기
* MSS : TCP의 최대 세그먼트 크기

### TCP / UDP 차이점
* **연결지향 / 비연결지향**
* 데이터 순서 보장 / 데이터 순서 보장하지 않음
* 흐름제어와 혼잡을 제어함 / 흐름제어 혼잡제어를 하지 않음

### HTTP2 / HTTP3
* **차이점**
  * HTTP2는 TCP위에서 동작, HTTP3는 UDP에서 동작
* HTTP2
  * Multiplexing을 지원하여 동시에 여러 컨텐츠가 전송될 수 있어 로딩 속도가 빨라짐
  * 하지만, 단일 TCP 연결 방식에 의해 TCP연결에서 packet loss가 일어나는 등 네트워크 상태가 좋지 않으면, HTTP1보다 품질이 좋지 않은 경우도 있음
  * HPACK 압축 포맷을 사용하여 헤더 데이터를 압축한다
  * 서버가 클라이언트에게 필요한 리소스를 클라이언트 요청 전에 미리 요청할 수 있다.
* HTTP3
  * 구글에서 TCP로 인해 생긴 병목을 해결하기 우이해 만든 UDP기반의 QUIC를 사용
  * 다수의 연결 스트림을 만들어 전송함으로써 HOL Blocking을 피함
  * 서로 다른 스트림은 독립적으로 동작하여 순서를 보장하지는 못하지만, Packet loss로 전체 전송 속도가 떨어지는 현상은 줄어들게 됨
  * IP주소나 포트 변경시에도 기존 QUIC연결을 유지할 수 있다
  * 헤더 압축과 함께 각 스트림의 독립적인 흐름제어를 제공한다
  * QUIC는 TCP보다 더 효율적인 손실 감지 및 복구 메커니즘을 제공

### 웹소켓 프로토콜로의 업그레이드 과정
> 클라이언트와 서버간의 초기 HTTP 핸드셰이크를 통해 이루어짐.  
> 이 과정에서 클라이언트는 웹소켓 연결을 요청하고, 서버가 이를 수락함으로써 HTTP연결이 웹 소켓으로 전환
1. **클라이언트에서의 웹 소켓 연결 요청**
  * 클라이언트는 서버에 HTTP GEP요청을 보내고, 이 요청에는 웹소켓 연결을 위한 특별한 헤더들이 포함 됨.
     * Upgrade: websocket
       > HTTP 프로토콜을 웹소켓 프로토콜로 업그레이드하고자 함을 나타냄
     * Connection: Upgrade
       > 현재의 연결을 유지하면서 프로토콜을 전환하고자 함을 나타냄
     * Sec-WebSocket-Key
       > 서버에 의해 사용되어 응답을 생성하는데 사용되는 무작위로 인코딩 된 값.
     * Sec-WebSokcet-Version
       > 클라이언트가 사용하는 웹소켓 프로토콜의 버전을 명시함
2. **서버에서의 응답 및 프로토콜 업그레이드**
  * 서버가 웹소켓 연결을 지원하고 클라이언트의 요청을 수락하는 경우, 다음과 같은 HTTP 응답을 보냄
     * HTTP/1.1 101 Switching Protocols
       > 서버가 웹소켓 프로토콜의 업그레이드를 확인함
     * Upgrade: websocket
       > 서버가 웹 소켓 프로토콜로의 업그레이드를 확인함.
     * Connection: Upgrade
       > 형재의 연결이 웹소켓 연결로 전환됨을 나타냄
     * Sec-WebSocket-Accept
       > 클라이언트의 Sec-WebSocket-Key헤더 값을 기반으로 생성된 값이며, 클라이언트가 서버의 응답을 확인하는데 사용
3. **웹 소켓 연결의 시작**
  * 위의 핸드셰이크 과정이 성공적으로 완료되면, HTTP연결은 웹소켓 연결로 업그레이드 
  * 이후의 데이터 교환은 웹소켓 프로토콜을 통해 이루어짐.
  * 이 시점부터 클라이언트와 서버 간에는 실시간, 양방향 통신이 가능해짐

### 웹소켓 프로토콜로의 업그레이드 과정의 필요 이유
> 웹 통신에서 실시간, 양방향 통신을 가능하게 하기 위해 필요함
* **HTTP의 제한 극복**
  * 기존의 HTTP 프로토콜은 요청-응답기반으로 작동함
  * 이는 클라이언트가 요청을 보내고 서버가 응답하는 단방향 통신만을 지원함
  * 웹소켓은 이러한 HTTP의 제한을 극복하고, 서버와 클라이언트 간의 `지속적이고 양방향 통신을 가능`하게 함
* **실시간 데이터 교환**
  * 많은 현대 웹 애플리케이션은 `실시간으로 데이터를 교환`해야 하는 필요성이 있음
  * 실시간 통신 요구사항을 충족시키기 위해 필요함
  * 네트워크 효율성 향상
  * 웹소켓은 연결을 한번만 수립하고 이를 지속적으로 유지함
  * 매번의 HTTP요청마다 새로운 연결을 만드는 것보다 네트워크 자원을 효율적으로 사용하게 함
* **낮은 지연시간**
  * 웹소켓은 연결이 지속되는 한, 데이터를 빠르게 주고받을 수 있어 지연시간을 최소화함.
  * 특히 인터랙티브한 애플리케이션에서 중요한 요소임
* **서버 푸시 기능**
  * 전통적인 HTTP통신에서는 클라이언트가 먼저 요청을 보내야 서버가 응답할 수 있음
  * 웹소켓을 통해 `서버는 클라이언트의 요청 없이도 데이터를 클라이언트에게 푸시`할 수 있음

### 웹소켓과 TCP의 차이점
* **기본 프로토콜**
  * TCP 소켓
    * `TCP 소켓은 네트워크 계층에서 직접 동작`하며 클라이언트와 서버간의 저수준 연결을 제공
    * 일반적인 네트워크 통신에서 사용되며 HTTP,FTP등의 다양한 프로토콜이 이를 기반으로 동작
  * 웹 소켓
    * `HTTP 프로토콜 위에서 동작`함
    * 브라우저와 웹 서버간의 양방향 통신을 위해 설계되었으며, 웹 애플리케이션에서 실시간 통신이 필요할 때 사용
* **연결 방식**
  * TCP 소켓
    * 저수준의 연결 지향적 통신을 제공
    * 클라이언트와 서버간에 지속적인 연결을 만들고, 데이터가 순서대로 정확하게 전송되도록 보장
  * 웹 소켓
    * 처음 연결 시 HTTP요청을 통해 시작되며, 이후 프로토콜이 업그레이드 되어, 웹 소켓 연결로 전환 됨
    * 양방향 연결이며, 데이터가 실시간으로 교한될 수 있음
* **데이터 형식과 처리**
  * TCP 소켓
    * 원시바이트 형태로 전송됨
    * 데이터의 정확한 전송만을 보장하며, 데이터 형식과 처리는 애플리케이션 수준에서 관리되어야 함
  * 웹 소켓
    * 텍스트(문자열)와 이진 데이터 모두를 지원
    * 웹소켓 API는 데이터를 쉽게 보내고 받을 수 있도록 고수준의 인터페이스를 제공
* **보안**
  * TCP 소켓
    * TCP 자체는 보안 기능을 제공하지 않으며, SSL/TLS와 같은 프로토콜을 사용하여 보안 강화 가능함
  * 웹 소켓
    * 보안 웹소켓(WebSocket Secure, wss://)을 사용하여 SSL/TLS를 통해 암호화된 연결을 제공함

### RSA 알고리즘
> RSA의 보안성은 큰 소수의 곱을 분해하는 것이 현실적인 시간 내에는 매우 어렵다는 수학적 사실에 기반     
> 현재의 컴퓨팅 기술로는 매우 큰 숫자에 대한 소인수분해가 실용적인 시간 내에 불가능하다고 여겨짐
<img width="549" alt="스크린샷 2024-01-01 오후 4 51 05" src="https://github.com/elephant97/TIL/assets/82919411/e733aeba-3f80-4330-a35a-33ee089ba6a9">
