# 20231231(회차) 멘토링 내용 정리📒

### 슬라이딩 윈도우
> tcp에서 수신자가 데이터를 잘 받지 못하면 데이터 전송속도를 늦추는데 그 떄 사용하는 방식
* **창의 크기를 크게 해서 (필요에 따라서는 작게) 여러 패킷을 논리적인 하나의 패킷으로 묶어서 처리를 하는 방식**
* 데이터를 전송하기 위한 가상의 컨테이너 공간
* MTU : 한번에 보낼 수 있는 패킷의 크기
* MSS : TCP의 최대 세그먼트 크기

### TCP / UDP 차이점
* **연결지향 / 비연결지향**
* 데이터 순서 보장 / 데이터 순서 보장하지 않음
* 흐름제어와 혼잡을 제어함 / 흐름제어 혼잡제어를 하지 않음

### HTTP2 / HTTP3
* **차이점**
  * HTTP2는 TCP위에서 동작, HTTP3는 UDP에서 동작
* HTTP2
  * Multiplexing을 지원하여 동시에 여러 컨텐츠가 전송될 수 있어 로딩 속도가 빨라짐
  * 하지만, 단일 TCP 연결 방식에 의해 TCP연결에서 packet loss가 일어나는 등 네트워크 상태가 좋지 않으면, HTTP1보다 품질이 좋지 않은 경우도 있음
  * HPACK 압축 포맷을 사용하여 헤더 데이터를 압축한다
  * 서버가 클라이언트에게 필요한 리소스를 클라이언트 요청 전에 미리 요청할 수 있다.
* HTTP3
  * 구글에서 TCP로 인해 생긴 병목을 해결하기 우이해 만든 UDP기반의 QUIC를 사용
  * 다수의 연결 스트림을 만들어 전송함으로써 HOL Blocking을 피함
  * 서로 다른 스트림은 독립적으로 동작하여 순서를 보장하지는 못하지만, Packet loss로 전체 전송 속도가 떨어지는 현상은 줄어들게 됨
  * IP주소나 포트 변경시에도 기존 QUIC연결을 유지할 수 있다
  * 헤더 압축과 함께 각 스트림의 독립적인 흐름제어를 제공한다
  * QUIC는 TCP보다 더 효율적인 손실 감지 및 복구 메커니즘을 제공

### 웹소켓 프로토콜로의 업그레이드 과정
> 클라이언트와 서버간의 초기 HTTP 핸드셰이크를 통해 이루어짐.  
> 이 과정에서 클라이언트는 웹소켓 연결을 요청하고, 서버가 이를 수락함으로써 HTTP연결이 웹 소켓으로 전환
1. **클라이언트에서의 웹 소켓 연결 요청**
  * 클라이언트는 서버에 HTTP GEP요청을 보내고, 이 요청에는 웹소켓 연결을 위한 특별한 헤더들이 포함 됨.
     * Upgrade: websocket
       > HTTP 프로토콜을 웹소켓 프로토콜로 업그레이드하고자 함을 나타냄
     * Connection: Upgrade
       > 현재의 연결을 유지하면서 프로토콜을 전환하고자 함을 나타냄
     * Sec-WebSocket-Key
       > 서버에 의해 사용되어 응답을 생성하는데 사용되는 무작위로 인코딩 된 값.
     * Sec-WebSokcet-Version
       > 클라이언트가 사용하는 웹소켓 프로토콜의 버전을 명시함
2. **서버에서의 응답 및 프로토콜 업그레이드**
  * 서버가 웹소켓 연결을 지원하고 클라이언트의 요청을 수락하는 경우, 다음과 같은 HTTP 응답을 보냄
     * HTTP/1.1 101 Switching Protocols
       > 서버가 웹소켓 프로토콜의 업그레이드를 확인함
     * Upgrade: websocket
       > 서버가 웹 소켓 프로토콜로의 업그레이드를 확인함.
     * Connection: Upgrade
       > 형재의 연결이 웹소켓 연결로 전환됨을 나타냄
     * Sec-WebSocket-Accept
       > 클라이언트의 Sec-WebSocket-Key헤더 값을 기반으로 생성된 값이며, 클라이언트가 서버의 응답을 확인하는데 사용
3. **웹 소켓 연결의 시작**
  * 위의 핸드셰이크 과정이 성공적으로 완료되면, HTTP연결은 웹소켓 연결로 업그레이드 
  * 이후의 데이터 교환은 웹소켓 프로토콜을 통해 이루어짐.
  * 이 시점부터 클라이언트와 서버 간에는 실시간, 양방향 통신이 가능해짐

### 웹소켓 프로토콜로의 업그레이드 과정의 필요 이유
> 웹 통신에서 실시간, 양방향 통신을 가능하게 하기 위해 필요함
* **HTTP의 제한 극복**
  * 기존의 HTTP 프로토콜은 요청-응답기반으로 작동함
  * 이는 클라이언트가 요청을 보내고 서버가 응답하는 단방향 통신만을 지원함
  * 웹소켓은 이러한 HTTP의 제한을 극복하고, 서버와 클라이언트 간의 `지속적이고 양방향 통신을 가능`하게 함
* **실시간 데이터 교환**
  * 많은 현대 웹 애플리케이션은 `실시간으로 데이터를 교환`해야 하는 필요성이 있음
  * 실시간 통신 요구사항을 충족시키기 위해 필요함
  * 네트워크 효율성 향상
  * 웹소켓은 연결을 한번만 수립하고 이를 지속적으로 유지함
  * 매번의 HTTP요청마다 새로운 연결을 만드는 것보다 네트워크 자원을 효율적으로 사용하게 함
* **낮은 지연시간**
  * 웹소켓은 연결이 지속되는 한, 데이터를 빠르게 주고받을 수 있어 지연시간을 최소화함.
  * 특히 인터랙티브한 애플리케이션에서 중요한 요소임
* **서버 푸시 기능**
  * 전통적인 HTTP통신에서는 클라이언트가 먼저 요청을 보내야 서버가 응답할 수 있음
  * 웹소켓을 통해 `서버는 클라이언트의 요청 없이도 데이터를 클라이언트에게 푸시`할 수 있음

### 웹소켓과 TCP의 차이점
* **기본 프로토콜**
  * TCP 소켓
    * `TCP 소켓은 네트워크 계층에서 직접 동작`하며 클라이언트와 서버간의 저수준 연결을 제공
    * 일반적인 네트워크 통신에서 사용되며 HTTP,FTP등의 다양한 프로토콜이 이를 기반으로 동작
  * 웹 소켓
    * `HTTP 프로토콜 위에서 동작`함
    * 브라우저와 웹 서버간의 양방향 통신을 위해 설계되었으며, 웹 애플리케이션에서 실시간 통신이 필요할 때 사용
* **연결 방식**
  * TCP 소켓
    * 저수준의 연결 지향적 통신을 제공
    * 클라이언트와 서버간에 지속적인 연결을 만들고, 데이터가 순서대로 정확하게 전송되도록 보장
  * 웹 소켓
    * 처음 연결 시 HTTP요청을 통해 시작되며, 이후 프로토콜이 업그레이드 되어, 웹 소켓 연결로 전환 됨
    * 양방향 연결이며, 데이터가 실시간으로 교한될 수 있음
* **데이터 형식과 처리**
  * TCP 소켓
    * 원시바이트 형태로 전송됨
    * 데이터의 정확한 전송만을 보장하며, 데이터 형식과 처리는 애플리케이션 수준에서 관리되어야 함
  * 웹 소켓
    * 텍스트(문자열)와 이진 데이터 모두를 지원
    * 웹소켓 API는 데이터를 쉽게 보내고 받을 수 있도록 고수준의 인터페이스를 제공
* **보안**
  * TCP 소켓
    * TCP 자체는 보안 기능을 제공하지 않으며, SSL/TLS와 같은 프로토콜을 사용하여 보안 강화 가능함
  * 웹 소켓
    * 보안 웹소켓(WebSocket Secure, wss://)을 사용하여 SSL/TLS를 통해 암호화된 연결을 제공함

### RSA 알고리즘
> RSA의 보안성은 큰 소수의 곱을 분해하는 것이 현실적인 시간 내에는 매우 어렵다는 수학적 사실에 기반     
> 현재의 컴퓨팅 기술로는 매우 큰 숫자에 대한 소인수분해가 실용적인 시간 내에 불가능하다고 여겨짐
<img width="549" alt="스크린샷 2024-01-01 오후 4 51 05" src="https://github.com/elephant97/TIL/assets/82919411/e733aeba-3f80-4330-a35a-33ee089ba6a9">

### HTTPS의 통신 과정
> HTTPS는 HTTP에 SSL또는 TLS프로토콜을 결합하여 통신을 암호화하는 방식     
> 데이터의 기밀성과 무결성을 보장하며 중간자공격(MitM)으로 부터 보호함
1. 클라이언트가 서버에 연결 요청
   > 사용자의 브라우저(클라이언트)가 HTTPS를 통해 웹 사이트(서버)에 접속 시도
2. 서버의 디지털 인증서 제공
   > 서버는 클라이언트에게 자신의 공개키와 함께 디지털 인증서 제공     
   > 이 인증서는 신뢰할 수 있는 인증기관(CA)에 의해 발급되며, 서버의 신원 증명      
   > CA는 인증서의 내용에 대해 해시를 계산하고 이 해시를 자신의 개인키로 사용하여 서명함
3. 인증서 검증
   > 클라이언트는 받은 인증서를 검증하여 서버의 신뢰성 확인     
   > 인증서가 유효하고 CA에 의해 신뢰받는 것으로 확인되면, 통신을 계속 진행함
4. 대칭 키 생성 및 공유
   > 클라이언트는 새로운 대칭 키(세션 키)를 생성하고, 서버의 공개 키를 사용하여 대칭키를 암호화 함    
   > 암호화 된 대칭키는 서버에게 전송 됨
5. 대칭 키 복호화 및 세션시작
   > 서버는 자신의 개인 키를 사용하여 대칭 키를 복호화 함     
   > 클라이언트와 서버는 대칭키를 사용하여 모든 통신을 암호화하고 복호화 할 수 있음    
   > 이 대칭키는 세션이 유지되는 동안만 사용되고, 세션이 종료되면 폐기됨
6. 암호화 된 데이터 교환
   > 클라이언트와 서버간의 모든 데이터 교환은 대칭키를 사용하여 암호화 되며, 이를 통해 데이터의 기밀성과 무결성을 보장함
7. 세션 종료
   > 통신이 완료되면 세션 키는 폐기 되고, 연결이 안전하게 종료 됨

### 서버에서 발급된 Session ID가 브라우저에 저장되는 과정
* 세션 ID 생성(서버) -> 세션 ID 서버 응답에 포함(Set-Cookie필드) -> 브라우저에 쿠키 저장 -> 브라우저에서 서버로의 후속 요청 -> 세션 유지 및 관리

### JWT(JSON WEB TOKEN)방식
> RESTful API와 마이크로 서비스 아키텍처를 사용하는 애플리케이션에서 주로 선호함
* 상태 비저장
  * JWT는 상태 비저장 인증 방식으로 서버측에서 사용자의 인증 상태를 유지할 필요가 없어 서버의 세션관리 부담을 줄이며,     
    서버간의 부하 분산 및 확장성 측면에서 유리함
* 분산 시스템에 적합
  * 마이크로 서비스 및 분산 시스템 아키텍처에서 JWT는 서비스 간의 인증을 용이하게 함
  * 하나의 JWT가 여러 서비스에서 인증 수단으로 사용될 수 있으며,각 서비스는 독립적으로 토큰의 유효성을 검증할 수 있음
* 모바일 및 크로스-플랫폼 인증 지원
  * 다양한 클라이언트에서 인증 정보를 쉽게 교환할 수 있게 해줌
  * 모바일 앱과 웹 애플리케이션 간의 통합을 간편하게 함
* 보안성
  * JWT는 디지털 서명되어 있어 데이터의 무결성을 보장함
  * 토큰이 탈취되거나 변조되는 것을 방지함
* 확장성과 효율성
  * JWT는 클라이언트 측에 저장되며, 서버는 요청마다 토큰의 유효성만을 검증하면 되므로, 서버의 리소스 사용을 줄이고 확장성을 높일 수 있다.
* 개발의 용이성
  * JWT는 자체적으로 필요한 모든 정보를 담고있어, 별도의 데이터베이스 조회 없이 인증과 권한 부여가 가능함
* **단점**
  * 한번 발급된 JWT는 만료 시간이 도래하기 전까지는 무효화 시킬 수 없음
  * 토큰이 탈취될 경우 보안상의 위험이 있음
  * 따라서 JWT를 사용할 떄에는 보안 조치와 함께 적절한 만료 시간 설정, 토큰 리프레시 전략등을 고려하는 것이 중요

### SQL Injection 이란?
> 보안 취약점 중 하나로, 악의적인 사용자가 웹 애플리케이션을 통해 데이터베이스 시스템에 비정상적인 SQL 명령을 주입하여 실행시키는 공격

### 커맨드 패턴이란?
> 행동 디자인 패턴의 한 종류로, 요청을 객체의 형태로 캡슐화하여 사용자가 요청을 보내는 쪽과 요청을 처리하는 쪽을 분리하는 것이 목적    
> 이 패턴은 명령을 실행하는 호출자와 실제 작업을 수행하는 수신자 사이의 결합도를 줄이며, 명령을 클래스로 표현하여 확장성과 유연성을 증가시킴
* 장점
  * 분리와 확장성
    * 명령의 발행과 실행을 분리함으로써 시스템의 다른 부분에 영향을 미치지 않고 새로운 명령을 쉽게 추가할 수 있음.
  * 재사용과 조합
    * 이미 정의된 커맨드를 재사용하거나 조합하여 복잡한 작업을 수행할 수 있음.
  * 취소 및 로깅 기능
    * 커맨드 패턴은 명령의 기록, 취소 또는 재실행과 같은 추가적인 기능을 구현하기 쉽게 해줌.

### 리다이렉트
* 리다이렉트
  * 웹 브라우저나 다른 클라이언트가 특정 URL로 요청을 보낼 때, 그 요청을 다른 URL로 재 지시하는 방법
  * 웹 사이트의 구조 변경, URL의 단축, 서버 부하 분산, 사용자를 새로운 페이지로 이동시키는 등의 목적으로 활용 됨
* 리다이렉트 과정
  * 초기 요청
    * 사용자 또는 클라이언트가 웹 브라우저를 통해 특정 URL로 요청을 보냄
  * 서버 응답
    * 서버는 해당 요청에 대해 리다이렉트 응답을 보내고, 새로운 URL을 제공함
    * 이 응답에는 특정 HTTP 상태 코드가 포함 됨
  * 브라우저가 새 URL로 요청
    * 브라우저는 서버로부터 받은 URL로 자동으로 요청을 보냄
  * 최종 페이지 로드
    * 새 URL의 서버가 요청을 처리하고 최종 콘텐츠를 사용자에게 보냄
* 리다이렉트 종류
  * 301 리다이렉트 (Moved Permanently)
    * 영구적인 리다이렉트로, 원래의 페이지가 새 URL로 영구적으로 이동했음을 나타냄
    * 검색 엔진 최적화(SEO)에 영향을 주며, 이전 URL의 링크 가치를 새 URL로 전달함
  * 302 리다이렉트 (Found)
    * 일시적인 리다이렉트로, 원래 페이지가 임시로 다른 위치로 이동했음을 나타냄
    * SEO관점에서는 301리다이렉트 만틈 링크 가치를 전달하지 않음
  * 303 리다이렉트 (See Other)
    * 주로 Post요청 후에 사용되며, 클라이언트에게 GET방식으로 다른 URL을 요청하도록 지시함
  * 307 리다이렉트 (Temporary Redirect)
    * 302와 유사하지만, 307은 요청방식을 변경하지 않고 유지함
  * 308 리다이렉트 (Permanent Redirect)
    * 301과 유사하게 영구적인 리다이렉트를 나타내지만, 요청 방식을 변경하지 않고 유지함

### SEO(Search Engine Optiomization, 검색 엔진 최적화)
> 웹사이트나 웹 페이지를 검색 엔진에서 더 높은 순위에 노출시키기 위한 방법론과 기술    
> 웹사이트에 대한 자연스러운(유료 광고가 아닌) 검색 트래픽을 증가시키는 것이 목적
* **SEO의 주요 요소와 전략**
  1. 키워드 최적화(Keyword Optimization)
     * 웹사이트의 내용을 특정 키워드나 문구에 맞추어 최적화.
     * 이는 검색 엔진이 해당 키워드에 대한 쿼리(query)에 대해 웹사이트를 관련성 높은 결과로 판단하게 만듬.
  2. 콘텐츠 품질(Contents Quality)
     * 유익하고, 독창적이며, 관련성 높은 콘텐츠를 제공.
     * 고품질 콘텐츠는 사용자의 참여를 유도하고, 웹사이트에 대한 신뢰도를 높입니다.
  3. 백링크(Backlinks)
     * 다른 웹사이트들이 귀하의 웹사이트로 링크를 걸어주는 것.
     * 백링크는 검색 엔진에게 귀하의 웹사이트가 신뢰할 수 있고 관련성이 높다는 신호를 보냄.
  4. 사이트 구조(Site Structure) 및 사용자 경험(User Experience)
     * 웹사이트의 구조를 명확하고 사용하기 쉽게 설계하여 검색 엔진이 콘텐츠를 쉽게 크롤링하고 이해할 수 있게 함.
     * 또한 사용자 경험을 최적화하여 사이트 체류 시간과 상호작용을 증가시킴.
  5. 모바일 친화성(Mobile Friendliness)
     * 웹사이트가 모바일 기기에서도 잘 작동하도록 최적화.
     * 모바일 친화성은 검색 엔진 순위에 중요한 요소로 작용합니다.
  6. 메타 태그(Meta Tags)와 메타 설명(Meta Descriptions)
     * 웹 페이지의 HTML에 메타 태그와 메타 설명을 추가하여 검색 엔진에 페이지의 내용을 요약하여 전달.
     * 이는 검색 결과에서 사용자가 내용을 빠르게 이해할 수 있도록 도와줌.
  7. 속도 및 성능(Speed and Performance)
     * 웹사이트의 로딩 속도를 최적화 함.
     * 빠른 로딩 속도는 사용자 경험을 개선하고 검색 엔진 순위에 긍정적인 영향을 미침.

### PreparedStatement
* **장점**
  * 바인드 파라미터의 사용
    * PreparedStatement는 바인드 파라미터를 사용하여 SQL 쿼리를 실행할 수 있다
    * 쿼리에서 특정 값을 바인드 변수로 대체하는 방식으로, 이 변수들은 실행 시 실제 값으로 치환됨
  * 쿼리 캐싱
    * PreparedStatement는 같은 구조의 쿼리를 여러 번 실행할 때 데이터베이스에서 쿼리의 실행 계획을 캐싱할 수 있도록 해줌
    * 쿼리를 빠르게 수행할 수 있게 하며, 반복적인 SQL 파싱과 최적화 과정을 줄여줌
  * 보안 측면
    * 바인드 파라미터를 사용함으로써 SQL 인젝션 공격을 방지할 수 있다
    * 바인드 변수는 쿼리의 일부로 해석되지 않으므로, 악의적인 SQL 코드의 주입을 방지할 수 있다
    * 바인드 변수에 할당된 실제 값이 쿼리 문자열에 직접 포함되지 않아 외부에서 쿼리의 내용을 쉽게 파악하기 어렵다
  * 성능 향상
    * 쿼리가 미리 컴파일되고, 실행 계획이 재사용될 수 있기 때문에 성능이 향상됨
* **작동방식**
  * 쿼리의 구조와 데이터 분리
  * 실제 값의 할당
    * 쿼리 실행 시, 바인드 변수에 실제 값이 할당
    * 이 과정은 데이터베이스 드라이버 또는 데이터베이스 시스템 내부에서 처리
    
