# 20231217(4회차) 멘토링 내용 정리📒
==> 다시 볼 부분은 💡로 표시

### 여러 디자인 패턴
> 디자인 패턴을 만든 이유는 반복적으로 발생하는 문제들에 대한 해결책을 제공하기 위해 만들어짐.
* **싱글턴 패턴**
> 클래스의 인스턴스를 하나만 생성하고, 그 인스턴스에 대한 전역접근을 제공하는 디자인 패턴.
> 전체 시스템에서 단 하나의 인스턴스만 필요한 경우 사용된다.
   * 특징 및 사용
     * 전역 변수를 사용하지 않고 인스턴스에 대한 전역 접근을 제공한다.
     * 인스턴스가 단 하나만 존재함을 보장함.
     * 데이터베이스 연결 객체, 로거, 설정파일 등에서 사용 됨
   * 장점
     * 리소스의 중복 사용을 방지하고, 공유된 자원에 대한 일관된 접근을 제공함.
   * 단점
     * 전역 인스턴스이므로 코드의 결합도가 높아질 수 있으며, 멀티스레드 환경에서든 동시성 처리에 주의 필요.
* **Proxy 패턴**
> 어떤 객체에 대한 접근을 제어하거나 기능을 추가하기 위해 대리자(프록시)를 제공하는 디자인 패턴      
> 프록시는 실제 객체와 동일한 인터페이스를 구현하여 클라이언트로부터의 요청을 실제 객체로 전달합니다.
   * 특징 및 사용
     * 원격 프록시, 가상 프로시, 보호 프록시 등 다양한 유형이 있음
     * 네트워크 연결, 메모리 관리, 보안 등에서 사용 됨.
   * 장점
     * 실제 객체의 접근을 제어하거나 부가 기능을 추가할 수 있음.
   * 단점
     * 프록시를 통한 추가 계층으로 인해 시스템이 복잡해질 수 있으며, 응답 시간이 지연될 수 있음.
* **Factory Method 패턴**
> 객체의 생성을 서브클래스에 위임하는 디자인 패턴.
> 인터페이스를 통해 객체를 생성하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 함
   * 특징 및 사용
     * 객체 생성에 필요한 인터페이스를 정의하고, 어떤 클래스의 인스턴스를 생성할지는 서브클래스가 결정함
     * 객체 생성 로직을 클라이언트로 부터 분리하여 코드의 유연성을 높임
   * 장점
     * 클라이언트 코드와 생성되는 객체 간의 느슨한 결합을 제공함.
     * 새로운 객체 타입을 추가할 때 기존 코드를 변경할 필요가 없음.
   * 단점
     * 코드가 복잡해지고, 클래스의 수가 증가할 수 있음.

### G1 GC는 메모리 영역을 어느 기준으로 나누는가?
* 다수의 작은 영역(Regions)
   * G1 GC는 전체 힙을 동일한 크기의 여러 개의 작은 영역으로 나눔.
   * 각 영역은 대략 1MB에서 수 MB를 가지며, 이는 JVM을 시작할 때 설정할 수 있음
* 영역 유형
   * 각 영역은 Eden, Survivor, Old Generation중 하나로 지정 됨
   * 전통적인 Young/Old Generation 구조를 유지하지만, 더 다양하고 유연한 방식으로 메모리를 관리
* 동적 재할당
   * G1 GC는 실행 중에 영역의 유형을 동적으로 변경할 수 있음
   * Eden영역이 가득 차면, 일부 영역이 Survivor 또는 Old Generation으로 재지정될 수 있음
* Region의 선택과 가비지 컬랙션
   * G1 GC는 가비지 컬랙션을 수행할 때 전체 힙이 아닌 특정 영역을 대상으로 함
   * 가비지 컬랙션의 대상 영역은 가비지가 가장 많이 쌓인 영역을 우선적으로 선택하는 방식으로 결정 됨
* **분할기준**
  * 리전 기반의 분할
    * G1 GC는 전체 힙을 여러개의 동일한 크기의 리전으로 분할함.
    * 일반적으로 수백 킬로바이트에서 수 메가바이트 사이의 크기를 가짐
    * 각 리전은 서로 다른 종류의 메모리 영역(영, 세대)을 나타낼 수 있음
  * 세대별 관리
    * G1 GC는 영 영역과 올드영역 그리고 가끔 대기열 영역을 관리한다(Survivor)
    * 각 리전은 이 세대 중 하나에 할당 됨
      * Young Generation
        > 새로 생성된 객체들이 지정되는 영역. 젋은 세대의 가비지 컬랙션은 일반적으로 빠르게 이루어짐
      * Old Generation
        > 오랫동안 살아남은 객체들이 이동되는 영역. 늙은 세대의 가비지 컬랙션은 보통 더 많은 시간이 필요.
      * Survivor space
        > 객체들이 젊은 세대와 늙은 세대 사이에서 잠시 머무는 공간으로 사용될 수 있음
  * 동적 재구성
    * G1 GC은 실행중에 리전의 할당을 동적으로 조정할 수 있음.
    * 애플리케이션의 메모리 사용 패턴과 가비지 컬랙션 성능 목표에 따라 달라질 수 있음
  * 가비지 컬렉션의 우선순위 결정
    * G1 GC는 가비지 컬렉션을 수행할 때 회수 가능한 메모리 양과 가비지 컬렉션에 소요되는 시간 사이의     
      균형을 맞추려고 함. 이를 위해 어떤 리전을 우선적으로 수집할지 결정


### ArrayList와 Deque의 차이점
* ArrayList는 동적 배열이며, Deque는 양방향 큐이다
* ArrayList는 인덱스를 통한 빠른 접근이 가능하지만 중간 요소의 수정이 비효율적일 수 있다.
* Deque는 양쪽 끝에서의 추가/제거가 빠르지만 준간 요소의 접근은 더 느림
* ArrayList는 순서가 중요한 데이터 리스트 관리에 적합하고, Deque는 양방향 큐의 기능이 필요할 떄 사용함

### Quick Sort와 Merge Sort
* Quick Sort
  * 일반적인 상황에서 빠른 성능을 제공하며, 메모리 사용이 제한적인 환경에서 유리.
  * 최악의 경우(이미 정렬이 되어있는 경우) 매우 느려질 수 있으므로, 이를 고려해야 함.
* Merge Sort
  * 안정적인 정렬이 필요하거나 일정한 성능이 보장되어야 하는 경우에 적합.
  * 추가적인 메모리 사용이 가능한 환경에서 더 유리.

### Quick Sort가 이미 정렬된 상태에서 최악의 성능을 보이는 이유는?
> 피벗을 기준으로 두 부분으로 나누어 각 부분을 재귀적으로 정렬하기 때문
* 피벗 선택
  * 피벗의 배열의 첫 번째나 마지막 요소로 선택하는 경우, 이미 정렬된 배열에서는 매번 최소 또는 최대 요소가 피벗으로 선택 됨
* 불균형 분할
  * 선택된 피벗이 항상 최소 또는 최댓값일 경우, 배열은 한쪽은 0개의요소 다른 한쪽은 나머지 모든 요소로 분할됨
  * 분할 과정을 매우 불균형하게 만들기 때문에 효율적인 분할 정복의 장점을 상실하게 됨
* 재귀의 깊이
  * 불균형 분하은 재귀 호출의 깊이를 증가시킴
  * 결과적으로, Quick Sort의 재귀 깊이가 배열의 길이와 동일해져 매 호출마다 단 하나의 요소만 처리하게 됨
* 시간 복잡도 증가
  * Quick Sort의 시간 복잡도는 최악의 경우 O(n^2)에 이르게 됨
  * 각 단계에서 거의 전체 배열을 다시 검사해야하기 때문에 매우 비효율적 

 
