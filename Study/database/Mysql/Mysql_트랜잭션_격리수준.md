# Mysql 트랜잭션 격리수준

### 트랜잭션의 격리수준 (Transaction Isolation Level)
> 트랜잭션의 격리수준이란, 어떤 트랜잭션이 동시에 처리될 떄 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를      
> 볼 수 있게 허용할지 여부를 결정하는 것
* 트랜잭션의 격리 수준의 격리(고립)가 높은 수준은 아래의 순서와 같다(위에서부터 높은 순서이며, Auto Commit=false인 상태에서 발생)
  * SERIALIZABLE
  * REPEATABLE READ
  * READ COMMITED
  * READ UNCOMMITED

### Mysql 읽기/쓰기 Lock
* Mysql에서 Select for share/update는 대상 레코드에 각각 읽기/쓰기 잠금을 거는 것
* 순수한 select 작업은 아무런 레코드 잠금 없이 실행된다.
* 잠금 없는 일관된 읽기(Non-locking consistent read)란 순수한 select 문을 통한 잠금 없는 읽기를 의미하는 것

### SERIALIZABLE
> 가장 엄격한 격리 수준으로, 이름 그대로 트랜잭션을 순차적으로 진행함
* SERIALIZABLE에서 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로, 어떠한 데이터 부정합 문제도 발생하지 않음
* 하지만 트랜잭션이 순차적으로 처리되어야 하므로 동시 처리 성능이 매우 떨어짐
* 순수한 select 작업에도 대상 레코드에 넥스트 키 락을 읽기 잠금(공유 락, Shared Lock)으로 건다.
* 따라서 한 트랜잭션에서 넥스트 키 락이 걸린 레코드를 다른 트랜잭션에서는 절대 추가/수정/삭제 할 수 없다.
* SERIALIZABLE은 가장 안전하지만 가장 성능이 떨어지므로, 극단적으로 안전한 작업이 필요한 경우가 아니라면 사용해선 안된다.

### REPEATABLE READ
* 일반적인 RDMS는 변경전의 레코드를 언두 공간에 백업해둔다
* 변경 전/후 데이터가 모두 존재하므로(변경 전 레코드는 UNDO영역에), 동일한 레코드에 대해 여러 버전의 데이터가 존재한다고 하여    
  이를 MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)라고 부른다.
* MVCC를 통해 트랜잭션이 롤백 된 경우에 데이터를 복원할 수 있을 뿐만 아니라, 서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어할 수 있다.
* 각각의 트랜잭션은 순차 증가하는 고유한 트랜잭션 번호가 존재하며, 백업 레코드에는 어느 트랜잭션에 의해 백업되었는지 트랜잭션 번호를 함께 저장함
* 해당 데이터가 불필요해진다고 판단하는 시점에 주기적으로 팩그라운드 쓰레드를 통해 삭제한다.
* REPEATABLE READ는 MVCC를 이용해 **한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우에 부정합**이 생길 수 있다.
* SELECT로 조회한 경우 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견될 수 있는데, 이를 유령 읽기(Phantom Read)라고 한다
* 하지만 MVCC 덕분에 일반적인 조회에서 유령 읽기(Phantom Read)는 발생하지 않는다. 왜냐하면 자신보다 나중에 실행된 트랜잭션이 추가한 레코드는 무시하면 되기 때문이다
* 유령 읽기가 발생하는 경우
  * select for update를 통해 베타적 잠금(비관적 잠금, 쓰기잠금)을 걸었을 때 다른 트랜잭션에서 수행한 update 된 컬럼이 조회될 수 있음
  * undo 영역은 잠금을 걸 수 없기 때문이다.
  * 하지만 mysql은 갭 락을 지원하기 때문에 위와 같은 문제는 발생하지 않는다.
  
### READ COMMITED
* READ COMMITED는 커밋된 데이터만 조회가 가능하다.
* READ COMMITED는 REPEATABLE에서 발생하는 phantom read에 더해 non-reapeatable read(반복 읽기 불가능)문제까지 발생한다
* 다른 트랜잭션에서 update를 수행하고 커밋을 진행했을 시 내 트랜잭션에서 다른 트랜잭션에서 수행된 값이 보이는 것이다.
* READ COMMITED에서 반복 읽기를 수행하는 경우 다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라질 수 있다
* 따라서 이러한 데이터 부정합 문제를 Non-Repatable Read(반복 읽기 불가능)이라고 함
* 일반적인 경우에는 문제되지 않지만, 하나의 트랜잭션에서 동일한 데이터를 여러번 읽고 변경하는 작업이 금전적인 처리와 연결되는 경우 문제가 생길 수 있다.

### READ UNCOMMITTED
* 커밋하지 않은 데이터 조차도 접근할 수 있는 격리 수준이다
* READ UNCOMMITTED에서는 다른 트랜잭션의 작업이 커밋 또는 롤백되지 않아도 즉시 보이게 된다
* 위의 이유로 READ UNCOMMITTED는 RDBMS 표준에서 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다

---
[참고](https://mangkyu.tistory.com/299)
