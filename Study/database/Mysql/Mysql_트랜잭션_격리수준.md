# Mysql 트랜잭션 격리수준

### 트랜잭션의 격리수준 (Transaction Isolation Level)
> 트랜잭션의 격리수준이란, 어떤 트랜잭션이 동시에 처리될 떄 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를      
> 볼 수 있게 허용할지 여부를 결정하는 것
* 트랜잭션의 격리 수준의 격리(고립)가 높은 수준은 아래의 순서와 같다(위에서부터 높은 순서이며, Auto Commit=false인 상태에서 발생)
  * SERIALIZABLE
  * REPEATABLE READ
  * READ COMMITED
  * READ UNCOMMITED

### Mysql 읽기/쓰기 Lock
* Mysql에서 Select for share/update는 대상 레코드에 각각 읽기/쓰기 잠금을 거는 것
* 순수한 select 작업은 아무런 레코드 잠금 없이 실행된다.
* 잠금 없는 일관된 읽기(Non-locking consistent read)란 순수한 select 문을 통한 잠금 없는 읽기를 의미하는 것

### SERIALIZABLE
> 가장 엄격한 격리 수준으로, 이름 그대로 트랜잭션을 순차적으로 진행함
* SERIALIZABLE에서 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로, 어떠한 데이터 부정합 문제도 발생하지 않음
* 하지만 트랜잭션이 순차적으로 처리되어야 하므로 동시 처리 성능이 매우 떨어짐
* 순수한 select 작업에도 대상 레코드에 넥스트 키 락을 읽기 잠금(공유 락, Shared Lock)으로 건다.
* 따라서 한 트랜잭션에서 넥스트 키 락이 걸린 레코드를 다른 트랜잭션에서는 절대 추가/수정/삭제 할 수 없다.
* SERIALIZABLE은 가장 안전하지만 가장 성능이 떨어지므로, 극단적으로 안전한 작업이 필요한 경우가 아니라면 사용해선 안된다.

### REPEATABLE READ
* 일반적인 RDMS는 변경전의 레코드를 언두 공간에 백업해둔다
* 변경 전/후 데이터가 모두 존재하므로(변경 전 레코드는 UNDO영역에), 동일한 레코드에 대해 여러 버전의 데이터가 존재한다고 하여    
  이를 MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)라고 부른다.
* MVCC를 통해 트랜잭션이 롤백 된 경우에 데이터를 복원할 수 있을 뿐만 아니라, 서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어할 수 있다.
* 각각의 트랜잭션은 순차 증가하는 고유한 트랜잭션 번호가 존재하며, 백업 레코드에는 어느 트랜잭션에 의해 백업되었는지 트랜잭션 번호를 함께 저장함
* 해당 데이터가 불필요해진다고 판단하는 시점에 주기적으로 팩그라운드 쓰레드를 통해 삭제한다.
* REPEATABLE READ는 MVCC를 이용해 **한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우에 부정합**이 생길 수 있다.
* SELECT로 조회한 경우 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견될 수 있는데, 이를 유령 읽기(Phantom Read)라고 한다
* 하지만 MVCC 덕분에 일반적인 조회에서 유령 읽기(Phantom Read)는 발생하지 않는다. 왜냐하면 자신보다 나중에 실행된 트랜잭션이 추가한 레코드는 무시하면 되기 때문이다

  
