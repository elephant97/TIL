# 시간복잡도 계산 (Big-O 표기법) 정리📔

### 시간복잡도 별 경향성 표 
<img width="900" alt="image" src="https://github.com/elephant97/TIL/assets/82919411/779cffc4-293a-49e6-9921-1fa35cf31483">

### Big-O 표기법 별 정리
#### O(1)
  * 어떤 상황에도 딱 한번 만에 원하는 수행이 이루어 지는 것
    * ex) 배열의 인덱스에 접근하여 데이터를 가져올 때, hashMap에 데이터를 넣거나, 값을 가져올 때 한번에 할 수 있는지 가 포인트
      
#### O(N)
  * N개의 데이터가 주어졌을 때 N개를 모두 돌면서 수행이 이루어 지는 경우
    * ex) 배열에서 어떤 데이터를 찾을 때 선형 탐색이라고 부르며 순회하면서 하나씩 비교해야하는 경우 해당

#### O(logN)
  * N개의 데이터 중 하나를 비교하면 비교할 대상이 점점 반으로 줄어드는 경우 
    * ex) 이진탐색에서 해당 값이 들어갈 위치를 찾는 경우 왼쪽 노드와 오른쪽노드 중 자신이 들어가야 할 위치를 찾으면 반대쪽 노드는 비교할 필요가      
           없어지므로 반이 줄어들며, 비교할 수록 비교 대상이 해당 노드 아래의 데이터 중 반으로 줄어 듬
#### O(NlogN)
  * N개의 데이터를 정렬에서 분할하는 과정과 합치는 과정이 같이 일어나는 경우
    * ex) 퀵 정렬, 병합 정렬 처럼 더이상 쪼갤 수 없을 때 까지 나누다가(logN) 나뉜 데이터 기준으로 다시 합치는 과정(나뉜 데이터의 개수N)을      
          통해 완성하는 경우 logN의 과정 후 * N의 과정이 일어나므로 NlogN

#### O(NlogN)
  * N개의 데이터를 정렬에서 분할하는 과정과 합치는 과정이 같이 일어나는 경우
    * ex) 퀵 정렬, 병합 정렬 처럼 더이상 쪼갤 수 없을 때 까지 나누다가(logN) 나뉜 데이터 기준으로 다시 합치는 과정(나뉜 데이터의 개수N)을      
          통해 완성하는 경우 logN의 과정 후 * N의 과정이 일어나므로 NlogN

### O(N^2)
   * N*N의 배열에서 모든 데이터를 하나씩 순회해가면서 서로 비교하는 경우
     * ex) 2차원 배열에서 2중 for문을 사용하여 각 행마다 각 배열의 요소를 비교하여 답을 구하는 경우에 해당 함

### O(2^N)
   * 자신의 함수에서 자신의 합수를 두번 호출한 결과를 통해 값을 구하는 경우
     * ex) 재귀 호출 과정에서 해를 구할 때 자신의 함수를 2번 호출한 값을 도출하여 구하는 경우 N개의 데이터 모두 해당 과정이 일어나므로 N의 2제곱의 시간이 소요

 
