# [JPA]Dirty Checking(변경감지)

### JPA에서의 Dirty Checking(변경감지)이란
> JPA는 수정 관련 메서드가 존재하지 않고, JPA를 통해 데이터를 수정하려면, Entity를 조회하여 조회된 Entity의 데이터를 변경하면 DB에 자동으로 반영되는 기능을 Dirty Checking이라고 한다
* JPA의 데이터 변경 로직
  * 트랜잭션 시작
  * 영속성 Entity 조회(없으면 조회하여 영속화)
  * 조회한 영속성 Entity의 데이터 수정
  * 트랜잭션 커밋
* JPA는 영속성 컨텍스트에 엔티티를 보관할 때 최초의 상태를 저장하고 있음
* 이를 스냅샷이라고 하고, 트랜잭션이 끝나는 시점에 스냅샷과 달라진 부분을 비교하여 Update쿼리를 수행하게 됨
* 영속성 컨텍스트에서 관리하는 객체에 정보가 변경되면, 1차 캐시에 저장된 스냅샷과 비교하고 달라진 부분에 맞게 SQL을 쓰기 지연 SQL저장소에 저장함
* 이후 커밋되는 시점에 flush함
* 이 때 상태 변경 검사의 대상은 영속성 컨텍스트가 관리하는 엔티티에만 적용 됨
  * detach된 엔티티(준영속)
  * DB에 반영되기 전 처음 생성된 엔티티(비영속)

### @DynamicUpdate
* 업데이트 시 변경한 내용이 하나라도 update쿼리에는 엔티티의 모든 필드가 update됨
* 기본적으로 JPA는 전체 필드를 업데이트 하는 방식으로, Dirty Checking으로 생성되는 Update쿼리는 기본적으로 모든 필드를 업데이트 함
* 변경된 필드만 변경하지 않고 모든 필드를 Update함으로써 얻을수 있는 장점은 다음과 같다
  * 수정 쿼리가 항상 동이랗게 만들어지므로, 생성되는 쿼리가 같아 부트 실행시점에 미리 Update쿼리를 만들어서 재 사용이 가능 함
  * 데이터베이스 입장에서 동일한 쿼리를 받으면 이전에 파싱된 쿼리의 (바인드 변수의 이점) 재사용이 가능함
* 만일 하나의 엔티티에 필드가 많아져 update에 부담이 생긴다면 @DynamicUpdate를 사용하여 변경된 쿼리만 update하도록 할 수 있음

### 영속성 컨텍스트란
* 엔티티를 영구 저장하는 환경이라는 뜻으로 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 생성됨
* 이렇게 만들어진 영속성 컨텍스트는 엔티티 매니저를 통래 접근하고 관리할 수 있음
* 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리함
* 엔티티 매니저는 find, persist, merge메서드를 호출하여 엔티티를 영속성 컨텍스테 저장함
* 영속성 컨텍스틑 엔티티의 식별자의 값으로엔티티들을 구분함
* 따라서 영속 상태의 엔티티는 식별자 값이 반드시 있어야 함
* 영속성 컨텍스트는 엔티티를 DB에 저장을 트랜잭션을 커밋하는 순간 저장, 수정, 삭제 등 변경된 내용을 DB에 반영함

### Entity Life Cycle
* 비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태
* 영속: 영속성 컨텍스트에 저장된 상태
* 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
* 삭제: 삭제된 상태
