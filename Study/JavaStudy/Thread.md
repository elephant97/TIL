# Thread 📌
> 쓰레드(Thread)는 프로세스 내에서 실행되는 작업의 기본 단위.
> 하나의 프로세스에는 여러 개의 쓰레드가 존재할 수 있다.
> 각각의 쓰레드는 프로세스 내에서 독립적으로 실행되는 흐름이며, 각 쓰레드는 자체적인 레지스터와 스택을 가지고 있다.   
> **JVM은 아무런 옵션 없이 실행 시 적어도 32MB~64MB의 물리 메모리 점유함**

### Thread의 특징
* 경량성(Lightweight)
  > 프로세스보다 쓰레드는 더 가벼우며, 쓰레드 간의 전환(Context Switching)이 빠름. 쓰레드가 동일한 프로세스 내의 메모리를 공유하기 때문.
* 자원 공유
  > 쓰레드는 같은 프로세스 내의 다른 쓰레드와 메모리 공간을 공유할 수 있다. 이를 통해 효율적인 데이터 공유가 가능하며,
  > 이로 인해 프로세스 간 통신보다 빠르고 경제적.
* 동시성(Concurrency)
  > 여러 쓰레드가 동시에 실행될 수 있다. 여러 작업을 동시에 처리할 수 있도록 해주며, 다중 쓰레드 프로그래밍을 통해 성능을 향상시킬 수 있다.
* 독립성(Independence)
  > 각 쓰레드는 독립적으로 실행되기 때문에 하나의 쓰레드에서 예외가 발생하더라도 다른 쓰레드는 영향을 받지 않는다.
* 쓰레드 간 통신(Thread Communication)
  > 쓰레드 간의 통신은 일반적으로 공유된 메모리를 통해 이루어짐. 따라서 쓰레드 간 동기화가 필요할 수 있다.

### Runnable 인터페이스와 Thread클래스
> Thread를 생성하는 방법에는 크게 두 가지 방법이 있음.
> Runnable인터페이스 사용, Thread클래스를 사용하는 것.
* Runnable인터페이스 사용, Thread클래스 모두 java.lang 패키지에 있으므로, 별도로 import가 필요 없음
  > Runnable 인터페이스에 선언되어 있는 메소드는 **run()**하나임 -> 쓰레드가 시작되면 수행되는 메소드
* 쓰레드가 수행되는 우리가 구현하는 메소드는 run()메소드이다.
* 쓰레드를 시작하는 메소드는 Start()이다.
```java
  new Thread(runnable).start();
  thread.start();
```
* **다른 클래스를 extends를 사용해 확장하고 있는 클래스는 다중 상속이 불가능 하므로 Runnable인터페이스를 구현해서 사용하면 됨.**
* 쓰레드를 start()메소드를 통해 시작했다는 것은 프로세스가 아닌 하나의 쓰레드를 JVM에 추가하여 실행한다는 것

### Thread 클래스
* 모든 쓰레드는 이름이 있으며, 쓰레드 생성 시 이름을 지정하지 않았다면 그 쓰레드의 이름은 "Thread-n"이며, n은 쓰레드가 생성된 순서에 따라 증가함.
* 쓰레드 이름은 겹쳐도 예외가 발생하지는 않음
* 쓰레드 생성 시 쓰레드를 **ThreadGroup**으로 묶을 수 있으며, 이 클래스를 통해 각종 정보를 얻을 수 있음
* stackSize라는 값을 주어 스택 크기를 지정할 수 있으며, 쓰레드에서 얼마나 많은 메소드를 호출하는지 얼마나 많은 쓰레드가 동시에 처리되는지는
  JVM이 실행되는 OS의 플랫폼에 따라 매우 다르며, 경우에 따라 이 값이 무시될 수 있다.
* **Thread에서 말하는 Stack은 Stack클래스와 전혀 상관 없으며 자바 프로세스가 시작되면 실행 데이터 공간(Runtime data area)가 구성된다.**
  **그 중 하나가 스택이라는 공간이며, 쓰레드가 생성될 때 마다 별도의 스택이 할당 된다.**

### Sleep
* Thread.sleep()메소드를 사용할 때에는 항상 **Try-catch로 묶어주어야 한다 그리고 적어도 InterruptedException으로 catch해주어야만 한다.**
* main()메소드의 수행이 끝나더라도 main()메소드나 다른 메소드에서 시작한 쓰레드가 종료하지 않으면 해당 자바 프로세스는 끝나지 않는다
* **데몬 쓰레드는 예외**

### Thread클래스의 메소드
* Thread 클래스는 쓰레드의 속성을 확인하고, 지정하기 위한 메소드와 쓰레드 상태를 통제하기 위한 메소드로 나눌 수 있다.
* 쓰레드의 우선순위를 지정할 수 있는 setPriority(int newPriority)사용이 가능하나 기본값으로 사용하는 것을 권장한다.
    * 우선순위와 관련 있는 상수
      * MIN_PRIORITY : 가장 높은 우선순위 이며, 그 값은 10이다.
      * NORM_PRIORITY : 일반 쓰레드의 우선순위 이며, 그 값은 5다.
      * MAX_PRIORITY : 가장 낮은 우선순위 이며, 그 값은 1이다.

### Deamon Thread
> **쓰레드가 수행되기 전 데몬 여부를 지정해야만 데몬 쓰레드로 지정할 수 있으며, 데몬 쓰레드로 인식 된다.**
  * 데몬 쓰레드가 아닌 일반쓰레드는 해당 쓰레드가 끝날 때 까지 JVM이 기다리지만, 데몬쓰레드는 그 쓰레드의 수행 여부와 관련 없이    
    다른 수행중인 쓰레드가 없으면 JVM이 끝날 수 있다.
  * 모니터링 쓰레드를 데몬 쓰레드로 만들고, 부가적인 작업을 수행하는 쓰레드를 선언할 때에도 데몬쓰레드를 만듬.

### Synchronized
* 어떤 클래스나 메소드가 쓰레드에 안전하려면, Synchronized를 사용해야만 한다.
* 여러 쓰레드가 한 객체에 선언된 메소드에 접근하여 데이터를 처리하려고 할 때 동시에 연산을 수행하여 값이 꼬이는 경우가 발생할 수 있다.
* 동일한 하나의 객체의 메소드에서 인스턴스 변수를 수정하려고 할때 이러한 문제가 발생함.
* 만일 메서드에서만 사용하는 지역변수만 다루는 메소드는 사용할 필요가 없다.
  * Synchronized 사용하는 방법
    * 메소드 자체를 Synchronized로 선언하는 방법
    * 메소드 내의 특정 문장만 Synchronized로 감싸는 방법
* **Synchronized로 선언하여 사용하면 동일한 객체의 메소드에 여러 쓰레드가 접근하여도 한 순간에는 하나의 쓰레드만 이 메소드를 수행함.**
* **같은 객체를 참조할 때에만 유효함**
```java
Object lock=new Object();
public void plus(int value){
  synchronized(lock){
    amount+=value;
  }
}
public void minus(lock){
  synchronized(lock){
    amount-=value;
  }
}
```

### Thread를 통제하는 메소드
* **getState()** 메소드를 통해 쓰레드의 상태를 알 수 있다.
  * return 값 (State라는 enum클래스)
    * NEW
      > 쓰레드 객체는 생성되었지만, 아직 시작되지는 않은 상태
    * RUNNABLE
      > 쓰레드가 실행 중인 상태
    * BLOCKED
      > 쓰레드가 실행 중지 상태이며, 모니터 락이 풀리기를 기다리는 상태
    * WAITTING
      > 쓰레드가 대기중인 상태
    * TIMED_WAITING
      > 특정 시간만큼 쓰레드가 대기중인 상태
    * TERMINATED
      > 쓰레드가 종료된 상태
  * Thread가 끝날 때 까지 대기하는 **join()**메소드 의 경우 나노초로 지정할 시 0~999,999사이의 값이 아닌 경우
    IllegalArgumentException이 발생된다.
  * **Interrupt()** 메소드는 현재 수행중인 쓰레드를 InterruptedException을 발생시키며 중지시킨다
  * **isInterrupted()** 메소드를 통해 Interrupt()메소드로 인한 종료가 이뤄진 것인지 확인 가능함.
  * **interrupted()** 메소드를 통해 현재 쓰레드가 중지되어있는지 **isAllive()** 메소드를 통해 살아있는지 확인 가능

### Object 클래스에 선언 된 쓰레드와 관련있는 메소드들
* wait()
  > 다른 쓰레드가 Object 객체에 대한 notify()메소드나 notifyAll() 메소드를 호출할 대 까지 현재 쓰래드가 대기 long timeout    
  > 매개 변수를 지정할 시 해당 time만큼 기다림
* notify()
  > Object 객체의 모니터에 대기하고 있는 단일 쓰레드를 깨움    
  > 이 메소드를 통해 쓰레드를 깨울 경우, InterruptedException도 발생하지 않으며, wait이후의 문장도 정상적으로 수행됨    
  > 먼저 대기하고 있는 쓰레드 부터 깨움 여러개인경우 여러번 호출해주어야 함
* notifyAll()
  > Object 객체의 모니터에 대기하고 있는 모든 쓰레드를 깨움

### ThreadGroup
> 쓰레드 그룹은 기본적으로 운영체제의 폴더처럼 뻗어나가는 트리 구조를 가짐
* enumerate(Thread[] list)
  > 현재 쓰레드 그룹에 있는 모든 쓰레드를 매개변수로 넘어온 쓰레드 배열에 담음     
  > Thread 배열의 크기를 activeCount()를 통해 파악 후 그 개수만큼 정하면 된다.
* list()
  > 쓰레드 그룹의 상세 정보를 출력
