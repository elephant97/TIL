# 프록시의 한계와 문제점
김영한님 Spring 핵심원리 - 고급편

<br>

### 프록시와 내부 호출 문제와 방안
> 프록시로 호출된 실제 클래스에서 내부 메서드를 호출했을 시 프록시가 적용되지 않는 문제가 있음
> 이러한 문제를 해결하기 위해 3가지 방안이 있다.
  * **방안**
    * 자기 자신 주입
      > this.으로 호출하는 것이 아닌 자기 클래스에 자신을 주입하여 해당 객체로 호출하도록 함
      ```java
         public class CallServiceV1 {
           private CallServiceV1 callServiceV1;
           @Autowired
            public void setCallServiceV1(CallServiceV1 callServiceV1) {
               this.callServiceV1 = callServiceV1;
            }
          public void external() {
          log.info("call external"); callServiceV1.internal(); //외부 메서드 호출
          }
               public void internal() {
                   log.info("call internal");
          }
      }
      ```
    * 지연 조회
      > 스프링 빈을 지연해서 조회하는 방법
      ```java
        public class CallServiceV2 {
             private final ObjectProvider<CallServiceV2> callServiceProvider;
             public void external() {
                 log.info("call external");
                 CallServiceV2 callServiceV2 = callServiceProvider.getObject();
                 callServiceV2.internal(); //외부 메서드 호출
            }
             public void internal() {
                 log.info("call internal");
            }
        }
      ```
      ```java
         public class CallServiceV2 {
             private final ApplicationContext applicationContext;
             public void external() {
                 log.info("call external");
                 CallServiceV2 callServiceV2 = applicationContext.getBean(CallServiceV2.class);
                 callServiceV2.internal(); //외부 메서드 호출
            }
             public void internal() {
                 log.info("call internal");
            }
        }
      ```
    * 구조 변경
      > 내부에서 호출해야하는 메서드를 다른 클래스로 분리하여 해당 클래스로 호출하도록 함
      ```java
        @Component
        @RequiredArgsConstructor
        public class CallServiceV3 {
             private final InternalService internalService;
              public void external() {
              log.info("call external"); internalService.internal(); //외부 메서드 호출
              }
        }
      ```
      ```java
        @Component
        public class InternalService {
             public void internal() {
               log.info("call internal");
             }
        }
      ```
      
### 프록시 기술 한계 
> JDK 동적 프록시와 CGLIB를 사용해서 AOP프록시를 만드는 방법에 각각 장단점이 있다.    
> JDK 동적 프록시는 인터페이스가 필수이며, 인터페이스를 기반으로 생성    
> CGLIB는 구체 클래스를 기반으로 프록시 생성
* JDK 동적 프록시의 한계 - 타입 캐스팅
  * 인터페이스 기반으로 프록시를 생성하는 JDK 동적 프록시는 구체 클래스로 타입 캐스팅이 불가능한 한계가 있음
* 의존관계 주입
