

### Java

- 데이터 타입과 변수
    - 데이터 타입은 프로그램 내에서 다루어지는 데이터의 종류를 정의합니다
    - 컴퓨터 데이터를 어떻게 저장하고 처리해야 할지를 결정하는데 중요한 역할을 합니다
    - 데이터 타입에는 크게 기본타입과 참조타입이 있습니다
        - 기본타입은 정수 실수 문자 불리언 등이 있으며 메모리에 직접 값을 저장합니다.
        - 기본타입은 메모리의 영역 중 스택 영역에 저장됩니다.
        - 참조타입은 객체나 배열 같이 복잡한 데이터 구조를 참조하는 타입입니다.
        - 참조타입은 메모리의 주소를 저장하며 주소를 통해 실제 데이터에 접근합니다.
        - 참조타입은 스택에 주소를 저장하고, 실제 값은 힙영역에 저장되며 GC에 의해 메모리가 해제됩니다.
    - 변수는 데이터를 저장하기 위한 메모리 공간에 붙여진 이름입니다.
    - 변수를 사용함으로써 개발자는 특정 데이터에 접근하고, 수정할 수 있습니다.
    - 변수는 선언할 때 특정 데이터 타입을 가지며 이는 변수가 저장할 수 있는 데이터의 종류와 메모리 크기를 결정합니다.
    - 데이터 타입은 무엇을 저장할 수 있는가, 변수는 어디에 저장할 것인가를 나타냅니다.
- equals 함수가 2개의 객체가 같다는 것을 비교하는 방법
    - equals 함수에서 두 객체가 같다는 것을 비교하는 방법은 해당 객체의 equals 메서드가 어떻게 구현되어 있는지에 따라 달라짐
    - Object.equals() 메소드는 두 객체 참조가 동일한 객체를 가리키는지 비교합니다. 즉 같은 메모리 주소인지 확인합니다
    - 또한 대부분의 경우 equals메소드를 오버라이드 하여 객체의 내용이 같은지를 비교하는 방식으로 구현합니다
    - 객체의 동등성을 비교하기 위한 것으로 객체의 실제 데이터 값을 비교하는 로직을 포함한다
- String a = "1234" 와 String a = new String("1234")의 차이
    - String a = "1234"
        - 문자열 리터럴로 생성된 String 객체는 Java의 문자열 상수풀 (String Constant Pool)에 저장된다
        - 힙메모리에 존재하며, 같은 문자열 리터럴로 생성된 모든 String 객체는 이 풀에서 유일한 인스턴스를 공유함
        - 새로운 객체를 생성하는 대신에 상수풀에 있는 기존의 객체를 참조하게 되며 메모리 사용을 줄일고 성능을 향상시킬 수 있다
    - String a = new String(”1234”)
        - 새로운 메모리 영역에 할당된다
        - 같은 문자열이라도 new를 사용하여 객체를 생성하는 경우 새로운 객체가 메모리에 생성된다
        - 따라서 메모리 사용이 비효율적일 수 있다
- 참조값이 스택에 저장되는 이유
    - **성능**
        - 스택은 선입선출(LIFO) 구조로 되어 있으며, 데이터의 추가와 제거가 매우 빠릅니다. 메소드 호출 시 생성되는 참조 변수를 스택에 저장하면, 메소드의 실행이 끝나는 즉시 관련 로컬 변수와 참조들을 빠르게 정리할 수 있습니다.
    - **스코프 관리**
        - 스택에 저장된 참조 변수는 해당 변수가 선언된 메소드의 스코프에 속합니다. 메소드 실행이 완료되면 스택 프레임이 제거되고, 해당 메소드에서 생성된 모든 로컬 참조 변수도 함께 제거됩니다. 이는 메모리 누수를 방지하고, 메모리 사용을 효율적으로 관리하는 데 도움이 됩니다.
    - **메모리 효율성**
        - 참조 타입의 객체 데이터를 힙에 저장하고, 그 주소만을 스택에 저장함으로써, 메모리를 효율적으로 사용할 수 있습니다. 객체의 실제 데이터는 크기가 클 수 있으며, 이를 스택에 직접 저장하면 스택 오버플로우를 일으킬 위험이 있습니다. 반면, 힙은 이러한 대규모 데이터를 저장하고 관리하기에 적합한 구조를 가지고 있습니다.
- Iterator와 Iterable
    - Iterator
        - **목적과 역할:** **`Iterable`** 인터페이스는 클래스가 **`foreach`** 루프를 사용하여 순회될 수 있도록 하는 역할을 합니다. 반면, **`Iterator`** 인터페이스는 실제로 컬렉션의 요소를 순회하는 메커니즘을 제공합니다.
        - **사용 방법:** 클래스가 **`Iterable`** 인터페이스를 구현하면, 해당 클래스의 인스턴스는 **`foreach`** 루프에서 사용될 수 있습니다. **`Iterator`**는 이러한 순회를 실제로 구현하는 데 사용되며, 보통 **`Iterable`** 인터페이스의 **`iterator()`** 메소드에 의해 반환됩니다.
        - **인터페이스 메소드:** **`Iterable`**은 **`iterator()`** 메소드를 통해 **`Iterator`** 인스턴스를 제공합니다. **`Iterator`**는 **`hasNext()`**, **`next()`**, 그리고 **`remove()`**와 같은 메소드를 통해 순회와 요소 조작을 가능하게 합니다.
        - **`Iterable`**은 순회 가능성을 제공하는 인터페이스이며, **`Iterator`**는 실제 순회를 수행하는 인터페이스입니다.
- foreach
    - Iterable 인터페이스를 상속받고 있는 자료구조에서 사용 가능
    - next()메서드를 통해 다음 데이터를 가져오고 다음 데이터가 존재하는지는 hasNext()메서드를 통해 확인함
- RESTful의 설계원칙
- stateless
- synchronized
- 람다의 장점
- 스트림 API
    - **`Stream API`**를 사용할 때 데이터의 양을 고려하지 않으면 오히려 성능 저하 문제가 발생할 수 있습니다. 특히, 큰 데이터 세트를 처리할 때는, 스트림 연산들이 내부적으로 반복적으로 수행되면서 추가적인 비용을 발생시킬 수 있습니다. 또한, 병렬 스트림을 사용할 때는 적절한 상황에서만 사용해야 하며, 모든 상황에서 성능이 향상되는 것은 아닙니다. 데이터 소스의 분할성, 태스크의 단위 크기, 처리 과정에서 발생하는 오버헤드 등을 고려해야 합니다.
- Optional
    - **`Optional`**의 과도한 사용은 실제로 코드를 더 복잡하게 만들 수 있으며, **`null`** 처리를 제대로 하지 못하는 상황으로 이어질 수 있습니다. 특히, **`Optional`**을 필드 변수로 사용하거나, 컬렉션 타입의 **`Optional`** 사용 등은 안티패턴으로 간주되며, 이는 코드의 가독성을 저하시키고, 디버깅을 더 어렵게 만들 수 있습니다. **`Optional`**은 메소드의 반환 타입으로만 사용하는 것이 바람직합니다.
- **ExecutorService**
    - **`ExecutorService`**를 사용해 비동기적으로 실행하는 것이 유용한 작업에는 네트워크 호출, 복잡한 계산, 파일 I/O 작업, 데이터베이스 조회 등이 있습니다. 이런 종류의 작업들은 실행 시간이 오래 걸릴 수 있으며, 메인 스레드의 실행을 차단하지 않고 백그라운드에서 수행될 때 애플리케이션의 반응성을 개선할 수 있습니다.
- `@Transactional`
    - **`@Transactional`** 애노테이션은 **접근제어자가 public인 메서드에서만 올바르게 작동**합니다. Spring Framework에서 **`@Transactional`** 애노테이션을 사용할 때, Spring의 프록시 기반 AOP가 이를 처리하는데, 이는 public 메소드에서만 적절히 작동합니다. 따라서 private이나 protected 메소드에 **`@Transactional`**을 사용하면, 트랜잭션 관리가 예상대로 작동하지 않을 수 있습니다.
- **Generics**
    - 컴파일 시점에 타입 안정성을 제공하여 타입 캐스팅과 관련된 오류를 미리 방지하는 기능을 제공합니다. 이를 통해 컴파일러가 코드에서 발생하는 타입 관련 오류를 잡아내고, 프로그램의 안정성을 높일 수 있습니다. 제네릭을 사용하면 코드의 가독성도 향상되고, 반복적인 타입 캐스팅을 줄일 수 있어서 코드의 재사용성을 높일 수 있습니다
    - 장점
    제네릭을 사용하면 컬렉션과 같은 자료구조나 메서드에서 다양한 타입의 데이터를 처리할 수 있는 유연성을 제공합니다. 이를 통해 다형성을 활용하여 동일한 코드를 여러 타입에 대해 재사용할 수 있습니다. 따라서 코드의 재사용성과 가독성을 높일 뿐만 아니라, 프로그램의 유지보수성과 안정성도 향상됩니다
    - **`Generics`**를 사용할 때 고려해야 할 중요한 사항 중 하나는 **타입 안정성**입니다. 제네릭을 사용하여 컴파일 시간에 타입 안정성을 보장받지만, 제네릭 타입을 사용할 때에도 형변환 오류를 방지하기 위해 올바른 타입을 사용하는 것이 중요합니다. 특히, 제네릭 타입이 상속되어 있는 경우에는 부모 타입을 사용하고 값을 읽는 경우에는 **`instanceof`** 연산자를 사용하여 정확한 타입을 확인하는 것이 권장됩니다.
- generic type과 none generic type
    - 제네릭 타입과 비제네릭 타입의 가장 큰 차이는 타입 안전성과 코드의 재사용성에 있습니다. 제네릭을 사용함으로써 컴파일 시점에 타입 체크를 강화할 수 있으며, 명시적인 캐스팅 없이 다양한 타입의 객체를 안전하게 처리할 수 있습니다. 반면, 비제네릭 타입은 타입 안전성이 낮고 코드의 재사용성이 떨어지며, 명시적인 캐스팅이 필요합니다.
- 자바에서 **`equals()`**와 **`==`** 연산자의 차이점
    - **`equals()`는 객체의 내용을 비교하는 데 사용되고, `==` 연산자는 객체의 참조를 비교하는 데 사용됩니다.** **`equals()`** 메소드는 객체의 내용이 동일한지를 비교하는 데 사용되며, 개발자가 필요에 따라 해당 메소드를 재정의할 수 있습니다. 반면에 **`==`** 연산자는 객체의 참조를 비교하므로, 두 객체가 동일한 객체를 참조하는지를 확인할 때 사용됩니다.
    - **`equals()`** 메소드를 재정의할 때에는 반드시 **`hashCode()`** 메소드도 함께 재정의해주어야 합니다. 이는 객체의 동등성 비교를 위해 **`equals()`**를 사용하는 컬렉션 클래스들이 정상적으로 동작하기 위해서 필요한 작업
- 객체 직렬화(Serialization)
    - **객체를 이진 형태로 변환하여 저장한다**입니다. 객체 직렬화는 자바에서 객체를 이진 형태로 변환하여 파일이나 네트워크를 통해 전송하거나 저장하는 기술을 의미합니다. 이를 통해 객체의 상태를 영속화하고 전송할 수 있으며, 후에 역직렬화를 통해 원래의 객체 상태를 복원할 수 있습니다.
    - 직렬화된 객체를 역직렬화할 때 주의할 점은 보안 문제입니다. 외부로부터 제공받은 직렬화된 데이터를 역직렬화할 경우, 악의적인 코드를 실행할 수 있으므로 신뢰할 수 없는 소스에서의 데이터 역직렬화는 위험할 수 있습니다. 이를 방지하기 위해 역직렬화할 클래스에 대한 검증 및 보안 조치를 취할 필요가 있습니다.
- singleton
    - Singleton 패턴을 구현할 때에는 여러 스레드에서 동시에 접근할 수 있으므로, 멀티스레드 환경에서 안전하게 동작하도록 구현해야 합니다. 이를 위해 Lazy Initialization, Double-Checked Locking 등의 방법을 사용하여 인스턴스의 생성과 관련된 문제를 해결할 수 있습니다. 또한, Serialization과 Reflection을 사용할 때 Singleton 객체의 안전성을 보장하기 위한 추가적인 작업이 필요
- checked예외와 unchecked예외
    - Checked 예외는 컴파일 시에 확인되어야 하는 예외로, 개발자가 명시적으로 예외 처리 코드를 작성해야 합니다. 반면에 Unchecked 예외는 런타임 시에 발생하는 예외로, 개발자가 예외 처리 코드를 작성하지 않아도 컴파일러에서 강제하지 않습니다. 일반적으로 프로그래밍 오류에 의해 발생하는 예외가 Unchecked 예외에 해당합니다.
- 스레드 스케줄링 방법
    - 1. **선점형 스케줄링 (Preemptive Scheduling):** 이 방식은 우선순위나 타임 슬라이스(time slice)와 같은 요소들을 사용하여 현재 실행 중인 스레드가 다른 스레드에게 실행을 양보할 수 있도록 하는 방식입니다. 운영체제가 CPU를 현재 실행 중인 스레드에서 다른 스레드로 전환하는 것을 의미합니다. Java에서는 운영체제에 의해 지원되는 것이며, 스레드의 우선순위(priority)나 **`yield()`** 메소드를 통해 제어할 수 있습니다.
    - 2. **비선점형 스케줄링 (Non-preemptive Scheduling 또는 Cooperative Scheduling):** 이 방식은 스레드가 자발적으로 실행을 중단하거나 종료할 때까지 다른 스레드가 CPU를 얻을 수 없는 방식입니다. 스레드가 CPU를 점유한 상태에서만 다른 스레드가 실행될 수 있습니다. Java에서는 이 방식을 직접적으로 제어할 수 있는 방법은 제공하지 않습니다.
    - 자바에서는 운영체제에 의해 관리되며, 우선순위를 지정하여 스레드가 cpu를 얻는 순서를 정할 수 있음
- 접근 제어자
    - 접근 수준을 제어하여 정보 은닉을 구현하고, 캡슐화를 강화하여 객체 지향 프로그래밍 원칙을 유지함
- 리플랙션
    - 자바 프로그램이 자신의 구조를 조사하고 수정할 수 있는 능력을 말합니다. 이를 통해 프로그램이 실행 중에 클래스의 정보를 얻고, 객체를 생성하고, 메서드를 호출하고, 필드에 접근할 수 있습니다. 리플렉션을 사용하면 실행 시점에 클래스의 정보를 조사하여 동적으로 메서드를 호출하거나 수정할 수 있어, 다양한 유연성을 제공합니다.
    - **장점:** 리플렉션을 사용하면 프로그램이 실행 중일 때 클래스의 정보를 동적으로 조사하고 수정할 수 있어서 유연성이 크게 향상됩니다. 이를 통해 서비스를 중지시키지 않고도 메서드의 동작을 동적으로 수정할 수 있어서 유용합니다.
    - **단점:** 리플렉션을 자주 사용하면 성능에 부하를 일으킬 수 있습니다. 리플렉션은 실행 시점에 메서드나 필드에 대한 정보를 얻어오는 과정이 추가되므로, 일반적인 메서드 호출보다 느릴 수 있습니다.
    
    **예시:** 리플렉션을 활용하여 실행 시점에 예외를 올바르게 처리하는 경우가 있습니다. 예를 들어, 특정 클래스나 메서드가 실행되기 전에 해당 클래스나 메서드의 유효성을 검사하고 필요한 처리를 동적으로 수행할 수 있습니다.
    
- 객체와 클래스
    - 클래스
    객체를 생성하기 위한 설계도로, 어떤 종류의 객체를 생성할 것인지 정의함
    클래스는 필드(속성)와 메서드(동작)로 구성되어있으며, 객체의 상태와 행동을 정의함
    - 객체
    객체를 클래스의 인스턴스로, 클래스에 정의된 구조를 가지고 실제로 메모리에 할당된 데이터 
    객체는 클래스의 인스턴스화 과정을 통해 생성되며, 클래스에서 정의된 필드의 값과 메서드의 동작을 포함함

- OOP
    - SOLID 원칙
        1. **단일 책임 원칙 (Single Responsibility Principle - SRP):**
            - 하나의 클래스는 하나의 책임만 가져야 합니다. 클래스가 변경되어야 하는 이유는 오직 한 가지여야 합니다. 이를 통해 클래스는 한 가지 목적에 집중되어 있고, 변경에 유연하게 대처할 수 있습니다.
        2. **개방-폐쇄 원칙 (Open-Closed Principle - OCP):**
            - 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 변경에 대해서는 닫혀 있어야 합니다. 즉, 기존의 코드를 변경하지 않고도 새로운 기능을 추가할 수 있어야 합니다.
        3. **리스코프 치환 원칙 (Liskov Substitution Principle - LSP):**
            - 상속 관계에 있는 클래스들은 서브타입으로써 기반 타입의 인스턴스를 대체할 수 있어야 합니다. 이는 상위 타입의 객체를 하위 타입으로 치환해도 프로그램의 의도된 동작이 변하지 않음을 의미합니다.
        4. **인터페이스 분리 원칙 (Interface Segregation Principle - ISP):**
            - 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않아야 합니다. 큰 인터페이스를 더 작은 여러 개의 인터페이스로 분할하여 클라이언트가 필요한 인터페이스만 사용하도록 하는 것이 중요합니다.
        5. **의존 역전 원칙 (Dependency Inversion Principle - DIP):**
            - 고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 둘 모두 추상화에 의존해야 합니다. 또한, 추상화는 세부 사항에 의존해서는 안 되며, 세부 사항은 추상화에 의존해야 합니다.
    - 객체지향 프로그래밍의 4대 기본원칙
        1. **캡슐화(Encapsulation):** 데이터(속성)와 그 데이터를 처리하는 메서드를 하나로 묶어 객체를 구성하는 원칙입니다. 캡슐화를 통해 객체의 세부 구현을 숨기고 사용자에게는 필요한 인터페이스만을 제공하여 객체의 접근을 제어합니다. 이는 데이터의 안정성과 무결성을 보장합니다.
        2. **상속(Inheritance):** 한 클래스(부모 클래스)의 속성과 메서드를 다른 클래스(자식 클래스)가 이어받아 사용할 수 있게 하는 원칙입니다. 상속을 통해 코드의 재사용성을 높이고, 중복을 최소화할 수 있으며, 계층적 분류가 가능해집니다.
        3. **추상화(Abstraction):** 복잡한 현실 세계를 단순화하는 과정입니다. 추상 클래스나 인터페이스를 사용하여 공통적인 속성이나 기능을 추출하고, 구체적인 구현은 상속받는 클래스에서 담당하게 합니다. 이는 시스템의 복잡도를 줄이고, 관리를 용이하게 합니다.
        4. **다형성(Polymorphism):** 같은 이름의 메서드가 여러 클래스에서 다른 기능을 할 수 있게 하는 원칙입니다. 오버라이딩(Overriding)과 오버로딩(Overloading)은 다형성을 구현하는 두 가지 방법입니다. 다형성을 통해 코드의 유연성을 높이고, 유지보수를 용이하게 합니다.

- 오토마타
    - 유한 오토마타의 중요성
        1. **정규 언어의 인식:** 유한 오토마타는 정규 언어를 인식하는 데 사용됩니다. 정규 언어는 가장 단순한 형태의 언어로, 컴퓨터 과학에서 프로그래밍 언어의 구문 분석, 텍스트 처리, 패턴 매칭 등 다양한 분야에서 응용됩니다.
        2. **소프트웨어 및 하드웨어 설계:** 유한 오토마타는 소프트웨어 또는 하드웨어의 동작을 모델링하는 데 사용될 수 있습니다. 특히 상태 기반의 시스템 설계에서 유용하며, 설계의 정확성을 검증하는 데 도움을 줍니다.
        3. **복잡한 시스템의 단순화:** 유한 오토마타를 통해 복잡한 시스템을 유한한 상태로 나누어 간단하게 표현할 수 있습니다. 이는 시스템의 분석과 이해를 용이하게 하며, 문제를 더 쉽게 해결할 수 있게 합니다.
        4. **컴파일러 구현:** 컴파일러의 렉서(lexer)나 파서(parser)와 같은 구성 요소는 정규 언어와 문맥 자유 문법(context-free grammar)을 기반으로 하며, 이를 처리하기 위해 유한 오토마타와 유사한 개념이 사용됩니다.
        5. **효율적인 검색 알고리즘:** 문자열 검색, 패턴 매칭 알고리즘에서 유한 오토마타는 효율적인 검색을 가능하게 합니다. 예를 들어, 주어진 패턴을 텍스트에서 빠르게 찾는 데 유용합니다.

- 네트워크
    - 3Handshake
        1. 클라이언트가 서버에게 SYN (Synchronize) 패킷을 보내 연결을 시작하려는 의사를 표시합니다.
        2. 서버는 클라이언트의 SYN 패킷을 받고, 클라이언트에게 SYN-ACK (Synchronize-Acknowledgment) 패킷을 보내 연결 요청을 수락했다는 의사를 표시합니다.
        3. 마지막으로, 클라이언트는 서버에게 ACK (Acknowledgment) 패킷을 보내 이제부터 데이터 전송이 가능하다는 것을 알립니다.
    - TCP 패킷 손실 발생시
        - TCP는 데이터 전송 중 손실된 패킷을 감지하고 처리하기 위해 ACK(응답) 메시지와 타임아웃 메커니즘을 사용합니다. 각 TCP 패킷에는 순서 번호가 있어, 수신자는 이 순서 번호를 기반으로 모든 패킷을 올바르게 받았는지 확인할 수 있습니다. 만약 어떤 패킷이 손실되거나 순서대로 도착하지 않으면, 수신자는 누락된 패킷의 재전송을 요청할 수 있는 ACK를 송신자에게 보냅니다. 송신자는 타임아웃이 발생하거나, 예상하는 ACK를 받지 못했을 때 해당 패킷을 재전송합니다.
    - 4-way handshake
        1. **첫 번째 단계:** 클라이언트가 연결을 종료하겠다는 의사를 서버에게 전달하기 위해 FIN 패킷을 보냅니다. 이 시점부터 클라이언트는 FIN-WAIT-1 상태로 진입합니다.
        2. **두 번째 단계:** 서버는 클라이언트로부터 FIN 패킷을 받고, ACK 패킷을 클라이언트에게 보냅니다. 이때 서버는 CLOSE-WAIT 상태로 진입합니다. 클라이언트는 ACK를 받고 나서 FIN-WAIT-2 상태로 넘어갑니다.
        3. **세 번째 단계:** 서버가 현재 전송 중인 데이터를 모두 처리하고 나서 연결 종료 준비가 되면, 서버는 클라이언트에게 FIN 패킷을 보냅니다. 이 시점에서 서버는 LAST-ACK 상태로 진입합니다.
        4. **네 번째 단계:** 클라이언트는 서버로부터 FIN 패킷을 받고 ACK 패킷을 보냅니다. 클라이언트는 이 ACK를 보낸 후 TIME-WAIT 상태로 진입합니다. 일정 시간이 지난 후 연결이 완전히 종료됩니다.
        - TIME-WAIT 상태는 클라이언트가 마지막 ACK 패킷이 서버에게 도달했는지를 확인하기 위해 필요한 시간을 기다립니다

- OS
    - 가상 메모리
        - 가상 메모리는 컴퓨터의 주 메모리(램)보다 큰 메모리 공간을 프로그램에 제공하기 위해 사용되는 기술입니다. 실제 물리적 메모리 크기에 제한되지 않고, 프로그램이 더 많은 메모리를 사용할 수 있게 해줍니다. 이를 통해 시스템은 더 크거나 더 많은 프로그램을 동시에 실행할 수 있게 됩니다.
        - 가상 메모리 시스템은 주로 하드 디스크의 일부를 가상의 '메모리'로 사용합니다. 프로그램이 실행되면서 필요한 부분만을 실제 물리적 메모리로 가져오고(이를 '페이지 인'이라고 합니다), 물리적 메모리가 부족할 때는 사용하지 않는 데이터를 하드 디스크로 옮겨둡니다(이를 '페이지 아웃'이라고 합니다). 이 과정은 운영 체제에 의해 자동으로 관리됩니다.
        - **메모리 관리의 유연성**: 프로그램은 물리적 메모리의 한계를 넘어서는 메모리를 사용할 수 있습니다.
        - **메모리 보호**: 각 프로그램은 독립된 메모리 공간을 할당받으므로, 한 프로그램의 오류가 다른 프로그램이나 시스템 전체에 영향을 미치는 것을 방지할 수 있습니다.
        - **프로그램 간 메모리 공유**: 필요한 경우, 서로 다른 프로그램 간에 데이터를 공유하는 것이 용이합니다.
    - 페이지폴트
        - 페이지 폴트는 프로세스가 접근하려는 데이터나 코드가 물리적 메모리(RAM)에 없을 때 발생하는 현상입니다. 이 데이터나 코드는 가상 메모리 시스템에 의해 디스크의 스왑 공간(또는 페이지 파일)에 저장되어 있을 수 있습니다. 프로세스가 이런 데이터나 코드에 접근하려 할 때, 운영 체제는 해당 데이터가 현재 메모리에 없음을 감지하고, 페이지 폴트가 발생한다고 판단합니다.
        - 페이지 폴트가 발생하면, 운영 체제는 다음과 같은 단계를 수행합니다:
        1. **디스크에서 필요한 데이터를 찾습니다**: 운영 체제는 스왑 공간에서 해당 페이지를 찾아냅니다.
        2. **물리적 메모리에 공간 확보**: 필요한 경우, 운영 체제는 메모리 내의 다른 페이지를 스왑 아웃하여 디스크로 옮김으로써, 새로운 페이지를 위한 공간을 만듭니다.
        3. **데이터를 메모리로 읽어옵니다**: 디스크에서 찾은 데이터를 물리적 메모리로 옮깁니다.
        4. **페이지 테이블 업데이트**: 프로세스의 페이지 테이블을 업데이트하여, 새롭게 로드된 페이지의 물리적 메모리 주소를 반영합니다.
        5. **프로세스 계속 실행**: 프로세스가 다시 데이터에 접근할 때, 이제는 메모리에 존재하기 때문에 정상적으로 데이터를 사용할 수 있게 됩니다.
        - 페이지 폴트는 자주 발생할 경우 시스템의 성능에 부정적인 영향을 미칠 수 있습니다. 디스크 접근은 메모리 접근에 비해 상당히 느리기 때문에, 너무 많은 페이지 폴트가 발생하면, 시스템이 느려질 수 있습니다. 이를 방지하기 위해, 운영 체제는 보통 페이지 교체 알고리즘을 사용하여 가능한 한 효율적으로 메모리를 관리합니다.
    - LRU알고리즘 동작방식
        1. **접근 기록 유지**: 각 페이지가 마지막으로 접근된 시점을 추적합니다. 이를 위해 시간 스탬프나 카운터, 혹은 접근 순서를 나타내는 리스트를 사용할 수 있습니다.
        2. **메모리가 꽉 찼을 때의 교체**: 시스템이 새로운 페이지를 메모리에 로드해야 하지만 메모리가 꽉 차 있는 경우, LRU 알고리즘은 가장 오랫동안 사용되지 않은 페이지(즉, 가장 최근에 접근된 지 가장 오래된 페이지)를 찾아 메모리에서 교체합니다.
        3. **교체 후 업데이트**: 교체가 이루어진 후, 새로운 페이지에 대한 정보를 업데이트하고, 교체된 페이지의 접근 시간을 최신으로 설정합니다.
    - 페이지와 세그먼트
        - 페이지
            - 페이지는 가상 메모리 시스템에서 사용되며, 메모리를 고정된 크기의 블록으로 나눕니다. 예를 들어, 각 페이지가 4KB의 크기를 가질 수 있습니다.
            - 페이지는 물리적 메모리도 같은 크기의 '페이지 프레임'으로 나뉘어져 있으며, 가상 페이지는 이러한 페이지 프레임에 매핑됩니다.
            - 페이지 기반 시스템은 메모리를 균일하게 관리할 수 있게 해주며, 내부 단편화 문제를 줄일 수 있지만, 외부 단편화는 발생하지 않습니다.
            - 페이지 테이블을 사용하여 가상 주소를 물리적 주소로 매핑합니다.
        - 세그먼트
            - 세그먼트 방식은 프로그램의 메모리를 논리적인 단위, 예를 들어 함수, 객체, 배열 등으로 나누어 관리합니다. 각 세그먼트는 다른 크기를 가질 수 있습니다.
            - 이 방식은 프로그램의 논리적 구조를 더 잘 반영할 수 있으며, 메모리 보호와 공유 측면에서 이점을 제공할 수 있습니다.
            - 세그먼트는 세그먼트 테이블을 사용하여 가상 주소를 물리적 주소로 매핑합니다. 각 세그먼트는 시작 주소와 길이를 가집니다.
            - 세그먼트 방식은 외부 단편화 문제에 직면할 수 있지만, 내부 단편화는 발생하지 않습니다.
    - 프로세스와 스레드의 차이
        - 프로세스는 운영체제에서 독립적으로 실행되는 프로그램의 인스턴스로 독립된 메모리 공간(코드, 데이터, 힙, 스택 등)을 가짐
        - 스레드는 같은 프로세스 내에서 실행되는 실행 단위로, 프로세스의 자원과 메모리를 공유하며 같은 프로세스 내의 스레드와 코드섹션, 데이터섹션, 열린파일 같은 운영 체제 자원을 공유할 수 있지만 각각의 스택을 가지고 있어 실행 흐름이 독립적임
        - 자원 공유 관점에서 스레드 간의 통신과 자원 공유는 프로세스보다 효율적이지만 이로인해 동기화 문제가 발생할 수 있으며 프로세스간의 통신은 더 복잡하며 오버헤드가 큼
    
    - 뮤텍스와 세마포어
        - 뮤텍스
            - 상호 배제를 보장하는 메커니즘
            - 특정 스레드가 공유 자원에 접근하려 할 때 다른 스레드들은 그 자원에 접근할 수 없도록 함
            - 접근이 끝나면 뮤텍스를 해제하여 다른 스레드가 접근할 수 있도록 함
        - 세마포어
            - 동시에 자원에 접근할 수 있는 스레드의 수를 제한할 수 있음
            - 카운팅 세마포어라고 하며, 자원에 대한 동시 접근 제한에 유용
        

- 자료구조
    - 해시 테이블 작동원리
        - 키를 해시 함수를 통해 해시값으로 변환하고, 이 해시값을 인덱스로 사용하여 데이터를 배열 같은 데이터 구조에 저장함.
        - 이 과정에서 해시 함수가 중요한 역할을 하는데, 이 함수는 키를 고르게 분포된 해시값으로 매핑하여 테이블 내에서의 데이터 저장과 검색을 효율적으로 만듬
    - 해시 충돌이 무엇이며 처리방법
        - 해시 충돌은 두개 이상의 키가 같은 해시값을 가지게 되어, 동일한 위치에 저장되어야 하는 상황을 말함
        - 해시 테이블의 성능을 유지하기 위해 충돌을 효과적으로 관리하는 것이 중요
        - 해시 충돌 처리방법
            - 체이닝
                - 충돌이 발생한 모든 요소를 연결리스트로 만들어 동일한 해시 버킷에 저장하고 검색, 삽입, 삭제 연산 시 해당 리스트를 순회하여 원하는 값을 찾음
            - 오픈 어드레싱
                - 충돌이 발생하는 경우 다른 해시 버킷에 해당 요소를 저장함
                - 이를 위해 선형조사 제곱조사 더블해싱 등의 방법이 사용됨
    - 로드팩터
        - 로드 팩터는 해시 테이블에서 데이터의 저장된 정도를 나타내는 지표로, **`저장된 항목 수 / 버킷 수`**로 계산됩니다. 로드 팩터의 값이 너무 높으면 해시 충돌의 가능성이 증가하여 해시 테이블의 성능이 저하됩니다. 반면, 너무 낮은 경우 메모리를 비효율적으로 사용하게 됩니다. 일반적으로 로드 팩터가 특정 임계값(예: 0.75)을 초과하면 해시 테이블의 크기를 조정(재해싱)하여 성능을 유지
    - 해시테이블 사용이 좋은 경우
        - 검색속도가 중요한 경우
            - 평균적으로 상수 시간 내에 검색을 수행할 수 있으므로 검색 속도가 중요한 애플리케이션에 적합
        - 중복 없는 데이터 관리
            - 각 키가 유니크해야 하므로, 중복을 허용하지 않는 데이터 관리에 적합
        - 데이터 삽입과 삭제가 빈번한 경우
            - 해시 테이블은 데이터의 삽입과 삭제가 빠르게 수행될 수 있어 동적인 관리가 필요한 경우에 유용
        - 키 - 값 쌍으로 데이터 저장
            - 키에 해당하는 값을 빠르게 찾아야 할 때 해시테이블을 사용하면 효율적
    - ArrayList와 LinkedList
        - ArrayList
            - 인덱스를 통해 데이터 접근이 가능함
            - 리스트 중간에 값을 추가하거나 삭제하는 경우 데이터를 이동해야하기 때문에 상대적으로 느리다
            - 임의 접근이 빈번하거나 리스트 크기 변경이 적고 추가나 삭제가 주로 리스트의 끝에서 일어나는 경우에 적합
        - LinkedList
            - 내부적으로 이중 연결 리스트를 사용하여 요소들을 저장함
            - 임의 접근 시 순회를 해야함으로 상대적으로 느림
            - 리스트 중간에 추가 삽입이 상대적으로 빠름
            - 리스트의 크기 변경이 빈번하거나 중간에 요소를 추가하거나 삭제하는 작업이 많은 경우에 적합함
    - HashMap과 HashTable의 차이
        - HashMap
            - 비 동기화
            - iterator를 사용하여 요소를 순회함
            - fail-fast특성을 가지고 있어 반복 작업 중 구조가 변경되면 **ConcurrentModificationException예외를 던짐**
            - null키과 어려 null값이 허용됨
        - HashTable
            - null키와 null값이 모두 허용되지 않음
            - 스레드 세이프 하지만 동기화로 인해 hashmap보다 성능이 떨어질 수 있음
            - 열거형 또는 iterator를 사용하여 순회할 수 있고 Enumberation은 fail-fast 특성이 없음
    - Stack과 Queue는 내부적으로 어떤 자료구조를 사용하고 있는가
        - 일반적으로 이들은 배열(Array), 연결 리스트(Linked List), 동적 배열(Dynamic Array) 등을 사용하여 구현됩니다.
    - Tree
        - 계층적 관계를 표현하는 비선형 자료구조로, 노드와 이를 연결하는 엣지로 구성된다
        - 데이터가 계층적 구조를 가지거나, 빠른 검색 삽입 삭제등이 필요한 경우 유용하게 사용됨
        - 사용사례
            - 데이터베이스 인덱싱
            - 이진 검색 트리
            - 파일 시스템
            - 조직도
        - 이진트리는 연결리스트기반으로 데이터가 저장된다

- 데이터베이스
    - SQL Injection
        - SQL Injection 공격은 악의적인 SQL 코드를 데이터베이스에 입력함으로써 데이터베이스가 그 코드를 실행하게 만드는 공격 기법입니다. 공격자는 이 방법을 통해 데이터베이스에서 중요 정보를 빼내거나, 데이터를 변조하고, 심지어 데이터베이스를 제어할 수 있게 됩니다.
    - SQL Injection 방지 방법
        - Prepared Statements 사용
            - Prepared statements는 SQL 쿼리를 미리 컴파일하고, 실행 시점에만 파라미터를 전달합니다. 이 방법은 SQL 쿼리가 데이터베이스에 전송되기 전에 이미 구조가 정의되어 있기 때문에, SQL 삽입 공격을 방지할 수 있습니다.
        - ORM (Object Relation Mapping) 사용
            - ORM 프레임 워크는 SQL 쿼리를 직접 작성하지 않고 객체 지향 방식으로 데이터베이스를 관리하기 대문에 SQL 쿼리가 아닌 고수준의 API를 사용하여 데이터베이스와 상호작용 하여 Injection 공격의 위험을 줄일 수 있습니다.
    - 인덱스
        - 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색속도를 향상 시키기 위한 자료구조
        - 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 도움
        - 인덱스를 적용하지 않은 컬럼을 조회한다면 전체를 탐색하는 Full Scan이 수행 됨
        - 인덱스의 자료구조
            - 해시 테이블
                - 컬럼의 값으로 생성된 해시를 기반으로 인덱스 구현
                - 시간복잡도가 O(1)이라 검색이 매우 빠름
                - 부등호(<, >)와 같은 연속적인 데이터를 위한 순차 검색이 불가능 함
            - B-Tree
                - 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조
                - BTree의 리프 노드들을 LinkedList로 연결하여 순차 검색을 용이하게 함
                - 해시 테이블보다 나쁜 O(log 2n)의 시간 복잡도를 갖지만 해시 테이블보다 흔하게 사용됨
    - DB 정규화
        - 제 1 정규형
            - 모든 속성 값이 원자 값을 갖도록 분해한다

- 알고리즘
    - 퀵소트
        - 분할 정복 전략을 사용하는 정렬 알고리즘
        - 배열을 분할하여 정복하는 것으로 피벗이라고 하는 기준값을 선택한 다음 작은 요소는 피벗의 왼쪽 피벗보다 큰 요소는 피벗의 오른쪽으로 이동시키는 과정 반복하여 배열 정렬
            1. **피벗 선택**: 배열에서 하나의 요소를 피벗으로 선택합니다.
            2. **분할**: 피벗을 기준으로 배열을 두 부분으로 나눕니다. 피벗보다 작은 모든 요소는 피벗의 왼쪽에, 피벗보다 큰 모든 요소는 오른쪽에 오도록 합니다.
            3. **정복**: 분할된 두 부분을 재귀적으로 정렬합니다.
            4. **결합**: 정렬된 부분 배열들을 결합하여 최종적으로 정렬된 배열을 얻습니다. 퀵소트는 실제로 부분 배열들을 물리적으로 결합하지 않으며, 배열이 재귀적으로 정렬됩니다.
        - 시간 복잡도
            - 평균 O(n log n) 퀵소트는 평균적으로 모든 레벨에서 분할이 균등하게 이루어질 떄 가장 효율적
            - 최악 O(n^2) 피벗이 항상 최소값이나 최댓값으로 선택되어 분할이 한쪽으로 치우쳐질때 발생

- 컴퓨터 구조
    - 캐시메모리
        - 컴퓨터의 중앙 처리 장치와 메인 메모리 사이의 속도 차이를 극복하기 위해 사용 됨
        - cpu가 처리할 수 있는 속도에 비해 메인 메모리의 응답 속도가 느리기 때문에 이 속도 차이를 줄이리기 위해 캐시 메모리가 도입 되었음
        - 캐시 메모리의 주용성
            - 속도 향상
                - cpu 바로 옆에 위치하여, cpu 가 필요로 하는 데이터를 미리 가져와 저장해 둠
                - cpu가 데이터를 요청할 때 먼저 캐시 메모리에서 해당 데이터를 찾아보고 만약 존재한다면 메인 메모리보다 훨씬 빠르게 데이터를 제공함
                - 이 과정을 캐시 히트라고 하며, 캐시 히트율이 높을수록 시스템 성능이 좋아짐
            - 작동원리
                - 최근에 접근했거나 접근 빈도가 높은 데이터를 저장함으로써 효율적으로 작동함
                - 시간적 지역성과 공간적 지역성의 특성을 보임
