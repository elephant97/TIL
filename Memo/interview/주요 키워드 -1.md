# 기술면접 주요 키워드


- RESTful의 설계원칙
- stateless
- SQLinjection
- synchronized
- 람다의 장점
- 스트림 API
    - 맞습니다, **`Stream API`**를 사용할 때 데이터의 양을 고려하지 않으면 오히려 성능 저하 문제가 발생할 수 있습니다. 특히, 큰 데이터 세트를 처리할 때는, 스트림 연산들이 내부적으로 반복적으로 수행되면서 추가적인 비용을 발생시킬 수 있습니다. 또한, 병렬 스트림을 사용할 때는 적절한 상황에서만 사용해야 하며, 모든 상황에서 성능이 향상되는 것은 아닙니다. 데이터 소스의 분할성, 태스크의 단위 크기, 처리 과정에서 발생하는 오버헤드 등을 고려해야 합니다.
- Optional
    - **`Optional`**의 과도한 사용은 실제로 코드를 더 복잡하게 만들 수 있으며, **`null`** 처리를 제대로 하지 못하는 상황으로 이어질 수 있습니다. 특히, **`Optional`**을 필드 변수로 사용하거나, 컬렉션 타입의 **`Optional`** 사용 등은 안티패턴으로 간주되며, 이는 코드의 가독성을 저하시키고, 디버깅을 더 어렵게 만들 수 있습니다. **`Optional`**은 메소드의 반환 타입으로만 사용하는 것이 바람직합니다.
- **ExecutorService**
    - **`ExecutorService`**를 사용해 비동기적으로 실행하는 것이 유용한 작업에는 네트워크 호출, 복잡한 계산, 파일 I/O 작업, 데이터베이스 조회 등이 있습니다. 이런 종류의 작업들은 실행 시간이 오래 걸릴 수 있으며, 메인 스레드의 실행을 차단하지 않고 백그라운드에서 수행될 때 애플리케이션의 반응성을 개선할 수 있습니다.
- `@Transactional`
    - **`@Transactional`** 애노테이션은 **접근제어자가 public인 메서드에서만 올바르게 작동**합니다. Spring Framework에서 **`@Transactional`** 애노테이션을 사용할 때, Spring의 프록시 기반 AOP가 이를 처리하는데, 이는 public 메소드에서만 적절히 작동합니다. 따라서 private이나 protected 메소드에 **`@Transactional`**을 사용하면, 트랜잭션 관리가 예상대로 작동하지 않을 수 있습니다.
- **Generics**
    - 컴파일 시점에 타입 안정성을 제공하여 타입 캐스팅과 관련된 오류를 미리 방지하는 기능을 제공합니다. 이를 통해 컴파일러가 코드에서 발생하는 타입 관련 오류를 잡아내고, 프로그램의 안정성을 높일 수 있습니다. 제네릭을 사용하면 코드의 가독성도 향상되고, 반복적인 타입 캐스팅을 줄일 수 있어서 코드의 재사용성을 높일 수 있습니다
    - 장점
    제네릭을 사용하면 컬렉션과 같은 자료구조나 메서드에서 다양한 타입의 데이터를 처리할 수 있는 유연성을 제공합니다. 이를 통해 다형성을 활용하여 동일한 코드를 여러 타입에 대해 재사용할 수 있습니다. 따라서 코드의 재사용성과 가독성을 높일 뿐만 아니라, 프로그램의 유지보수성과 안정성도 향상됩니다
    - **`Generics`**를 사용할 때 고려해야 할 중요한 사항 중 하나는 **타입 안정성**입니다. 제네릭을 사용하여 컴파일 시간에 타입 안정성을 보장받지만, 제네릭 타입을 사용할 때에도 형변환 오류를 방지하기 위해 올바른 타입을 사용하는 것이 중요합니다. 특히, 제네릭 타입이 상속되어 있는 경우에는 부모 타입을 사용하고 값을 읽는 경우에는 **`instanceof`** 연산자를 사용하여 정확한 타입을 확인하는 것이 권장됩니다.
- 자바에서 **`equals()`**와 **`==`** 연산자의 차이점
    - **`equals()`는 객체의 내용을 비교하는 데 사용되고, `==` 연산자는 객체의 참조를 비교하는 데 사용됩니다.** **`equals()`** 메소드는 객체의 내용이 동일한지를 비교하는 데 사용되며, 개발자가 필요에 따라 해당 메소드를 재정의할 수 있습니다. 반면에 **`==`** 연산자는 객체의 참조를 비교하므로, 두 객체가 동일한 객체를 참조하는지를 확인할 때 사용됩니다.
    - **`equals()`** 메소드를 재정의할 때에는 반드시 **`hashCode()`** 메소드도 함께 재정의해주어야 합니다. 이는 객체의 동등성 비교를 위해 **`equals()`**를 사용하는 컬렉션 클래스들이 정상적으로 동작하기 위해서 필요한 작업
- 객체 직렬화(Serialization)
    - **객체를 이진 형태로 변환하여 저장한다**입니다. 객체 직렬화는 자바에서 객체를 이진 형태로 변환하여 파일이나 네트워크를 통해 전송하거나 저장하는 기술을 의미합니다. 이를 통해 객체의 상태를 영속화하고 전송할 수 있으며, 후에 역직렬화를 통해 원래의 객체 상태를 복원할 수 있습니다.
    - 직렬화된 객체를 역직렬화할 때 주의할 점은 보안 문제입니다. 외부로부터 제공받은 직렬화된 데이터를 역직렬화할 경우, 악의적인 코드를 실행할 수 있으므로 신뢰할 수 없는 소스에서의 데이터 역직렬화는 위험할 수 있습니다. 이를 방지하기 위해 역직렬화할 클래스에 대한 검증 및 보안 조치를 취할 필요가 있습니다.
- singleton
    - Singleton 패턴을 구현할 때에는 여러 스레드에서 동시에 접근할 수 있으므로, 멀티스레드 환경에서 안전하게 동작하도록 구현해야 합니다. 이를 위해 Lazy Initialization, Double-Checked Locking 등의 방법을 사용하여 인스턴스의 생성과 관련된 문제를 해결할 수 있습니다. 또한, Serialization과 Reflection을 사용할 때 Singleton 객체의 안전성을 보장하기 위한 추가적인 작업이 필요
- checked예외와 unchecked예외
    - Checked 예외는 컴파일 시에 확인되어야 하는 예외로, 개발자가 명시적으로 예외 처리 코드를 작성해야 합니다. 반면에 Unchecked 예외는 런타임 시에 발생하는 예외로, 개발자가 예외 처리 코드를 작성하지 않아도 컴파일러에서 강제하지 않습니다. 일반적으로 프로그래밍 오류에 의해 발생하는 예외가 Unchecked 예외에 해당합니다.
- 스레드 스케줄링 방법
    - 1. **선점형 스케줄링 (Preemptive Scheduling):** 이 방식은 우선순위나 타임 슬라이스(time slice)와 같은 요소들을 사용하여 현재 실행 중인 스레드가 다른 스레드에게 실행을 양보할 수 있도록 하는 방식입니다. 운영체제가 CPU를 현재 실행 중인 스레드에서 다른 스레드로 전환하는 것을 의미합니다. Java에서는 운영체제에 의해 지원되는 것이며, 스레드의 우선순위(priority)나 **`yield()`** 메소드를 통해 제어할 수 있습니다.
    - 2. **비선점형 스케줄링 (Non-preemptive Scheduling 또는 Cooperative Scheduling):** 이 방식은 스레드가 자발적으로 실행을 중단하거나 종료할 때까지 다른 스레드가 CPU를 얻을 수 없는 방식입니다. 스레드가 CPU를 점유한 상태에서만 다른 스레드가 실행될 수 있습니다. Java에서는 이 방식을 직접적으로 제어할 수 있는 방법은 제공하지 않습니다.
    - 자바에서는 운영체제에 의해 관리되며, 우선순위를 지정하여 스레드가 cpu를 얻는 순서를 정할 수 있음
- 접근 제어자
    - 접근 수준을 제어하여 정보 은닉을 구현하고, 캡슐화를 강화하여 객체 지향 프로그래밍 원칙을 유지함
- 리플랙션
    - 자바 프로그램이 자신의 구조를 조사하고 수정할 수 있는 능력을 말합니다. 이를 통해 프로그램이 실행 중에 클래스의 정보를 얻고, 객체를 생성하고, 메서드를 호출하고, 필드에 접근할 수 있습니다. 리플렉션을 사용하면 실행 시점에 클래스의 정보를 조사하여 동적으로 메서드를 호출하거나 수정할 수 있어, 다양한 유연성을 제공합니다.
    - **장점:** 리플렉션을 사용하면 프로그램이 실행 중일 때 클래스의 정보를 동적으로 조사하고 수정할 수 있어서 유연성이 크게 향상됩니다. 이를 통해 서비스를 중지시키지 않고도 메서드의 동작을 동적으로 수정할 수 있어서 유용합니다.
    - **단점:** 리플렉션을 자주 사용하면 성능에 부하를 일으킬 수 있습니다. 리플렉션은 실행 시점에 메서드나 필드에 대한 정보를 얻어오는 과정이 추가되므로, 일반적인 메서드 호출보다 느릴 수 있습니다.
    
    **예시:** 리플렉션을 활용하여 실행 시점에 예외를 올바르게 처리하는 경우가 있습니다. 예를 들어, 특정 클래스나 메서드가 실행되기 전에 해당 클래스나 메서드의 유효성을 검사하고 필요한 처리를 동적으로 수행할 수 있습니다.
    
- 객체와 클래스
    - 클래스
    객체를 생성하기 위한 설계도로, 어떤 종류의 객체를 생성할 것인지 정의함
    클래스는 필드(속성)와 메서드(동작)로 구성되어있으며, 객체의 상태와 행동을 정의함
    - 객체
    객체를 클래스의 인스턴스로, 클래스에 정의된 구조를 가지고 실제로 메모리에 할당된 데이터 
    객체는 클래스의 인스턴스화 과정을 통해 생성되며, 클래스에서 정의된 필드의 값과 메서드의 동작을 포함함
- SOLID 원칙
    1. **단일 책임 원칙 (Single Responsibility Principle - SRP):**
        - 하나의 클래스는 하나의 책임만 가져야 합니다. 클래스가 변경되어야 하는 이유는 오직 한 가지여야 합니다. 이를 통해 클래스는 한 가지 목적에 집중되어 있고, 변경에 유연하게 대처할 수 있습니다.
    2. **개방-폐쇄 원칙 (Open-Closed Principle - OCP):**
        - 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 변경에 대해서는 닫혀 있어야 합니다. 즉, 기존의 코드를 변경하지 않고도 새로운 기능을 추가할 수 있어야 합니다.
    3. **리스코프 치환 원칙 (Liskov Substitution Principle - LSP):**
        - 상속 관계에 있는 클래스들은 서브타입으로써 기반 타입의 인스턴스를 대체할 수 있어야 합니다. 이는 상위 타입의 객체를 하위 타입으로 치환해도 프로그램의 의도된 동작이 변하지 않음을 의미합니다.
    4. **인터페이스 분리 원칙 (Interface Segregation Principle - ISP):**
        - 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않아야 합니다. 큰 인터페이스를 더 작은 여러 개의 인터페이스로 분할하여 클라이언트가 필요한 인터페이스만 사용하도록 하는 것이 중요합니다.
    5. **의존 역전 원칙 (Dependency Inversion Principle - DIP):**
        - 고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 둘 모두 추상화에 의존해야 합니다. 또한, 추상화는 세부 사항에 의존해서는 안 되며, 세부 사항은 추상화에 의존해야 합니다.
