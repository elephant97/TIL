- OS
    - 가상 메모리
        - 가상 메모리는 컴퓨터의 주 메모리(램)보다 큰 메모리 공간을 프로그램에 제공하기 위해 사용되는 기술입니다. 실제 물리적 메모리 크기에 제한되지 않고, 프로그램이 더 많은 메모리를 사용할 수 있게 해줍니다. 이를 통해 시스템은 더 크거나 더 많은 프로그램을 동시에 실행할 수 있게 됩니다.
        - 가상 메모리 시스템은 주로 하드 디스크의 일부를 가상의 '메모리'로 사용합니다. 프로그램이 실행되면서 필요한 부분만을 실제 물리적 메모리로 가져오고(이를 '페이지 인'이라고 합니다), 물리적 메모리가 부족할 때는 사용하지 않는 데이터를 하드 디스크로 옮겨둡니다(이를 '페이지 아웃'이라고 합니다). 이 과정은 운영 체제에 의해 자동으로 관리됩니다.
        - **메모리 관리의 유연성**: 프로그램은 물리적 메모리의 한계를 넘어서는 메모리를 사용할 수 있습니다.
        - **메모리 보호**: 각 프로그램은 독립된 메모리 공간을 할당받으므로, 한 프로그램의 오류가 다른 프로그램이나 시스템 전체에 영향을 미치는 것을 방지할 수 있습니다.
        - **프로그램 간 메모리 공유**: 필요한 경우, 서로 다른 프로그램 간에 데이터를 공유하는 것이 용이합니다.
    - 페이지폴트
        - 페이지 폴트는 프로세스가 접근하려는 데이터나 코드가 물리적 메모리(RAM)에 없을 때 발생하는 현상입니다. 이 데이터나 코드는 가상 메모리 시스템에 의해 디스크의 스왑 공간(또는 페이지 파일)에 저장되어 있을 수 있습니다. 프로세스가 이런 데이터나 코드에 접근하려 할 때, 운영 체제는 해당 데이터가 현재 메모리에 없음을 감지하고, 페이지 폴트가 발생한다고 판단합니다.
        - 페이지 폴트가 발생하면, 운영 체제는 다음과 같은 단계를 수행합니다:
        1. **디스크에서 필요한 데이터를 찾습니다**: 운영 체제는 스왑 공간에서 해당 페이지를 찾아냅니다.
        2. **물리적 메모리에 공간 확보**: 필요한 경우, 운영 체제는 메모리 내의 다른 페이지를 스왑 아웃하여 디스크로 옮김으로써, 새로운 페이지를 위한 공간을 만듭니다.
        3. **데이터를 메모리로 읽어옵니다**: 디스크에서 찾은 데이터를 물리적 메모리로 옮깁니다.
        4. **페이지 테이블 업데이트**: 프로세스의 페이지 테이블을 업데이트하여, 새롭게 로드된 페이지의 물리적 메모리 주소를 반영합니다.
        5. **프로세스 계속 실행**: 프로세스가 다시 데이터에 접근할 때, 이제는 메모리에 존재하기 때문에 정상적으로 데이터를 사용할 수 있게 됩니다.
        - 페이지 폴트는 자주 발생할 경우 시스템의 성능에 부정적인 영향을 미칠 수 있습니다. 디스크 접근은 메모리 접근에 비해 상당히 느리기 때문에, 너무 많은 페이지 폴트가 발생하면, 시스템이 느려질 수 있습니다. 이를 방지하기 위해, 운영 체제는 보통 페이지 교체 알고리즘을 사용하여 가능한 한 효율적으로 메모리를 관리합니다.
    - LRU알고리즘 동작방식
        1. **접근 기록 유지**: 각 페이지가 마지막으로 접근된 시점을 추적합니다. 이를 위해 시간 스탬프나 카운터, 혹은 접근 순서를 나타내는 리스트를 사용할 수 있습니다.
        2. **메모리가 꽉 찼을 때의 교체**: 시스템이 새로운 페이지를 메모리에 로드해야 하지만 메모리가 꽉 차 있는 경우, LRU 알고리즘은 가장 오랫동안 사용되지 않은 페이지(즉, 가장 최근에 접근된 지 가장 오래된 페이지)를 찾아 메모리에서 교체합니다.
        3. **교체 후 업데이트**: 교체가 이루어진 후, 새로운 페이지에 대한 정보를 업데이트하고, 교체된 페이지의 접근 시간을 최신으로 설정합니다.
    - 페이지와 세그먼트
        - 페이지
            - 페이지는 가상 메모리 시스템에서 사용되며, 메모리를 고정된 크기의 블록으로 나눕니다. 예를 들어, 각 페이지가 4KB의 크기를 가질 수 있습니다.
            - 페이지는 물리적 메모리도 같은 크기의 '페이지 프레임'으로 나뉘어져 있으며, 가상 페이지는 이러한 페이지 프레임에 매핑됩니다.
            - 페이지 기반 시스템은 메모리를 균일하게 관리할 수 있게 해주며, 내부 단편화 문제를 줄일 수 있지만, 외부 단편화는 발생하지 않습니다.
            - 페이지 테이블을 사용하여 가상 주소를 물리적 주소로 매핑합니다.
        - 세그먼트
            - 세그먼트 방식은 프로그램의 메모리를 논리적인 단위, 예를 들어 함수, 객체, 배열 등으로 나누어 관리합니다. 각 세그먼트는 다른 크기를 가질 수 있습니다.
            - 이 방식은 프로그램의 논리적 구조를 더 잘 반영할 수 있으며, 메모리 보호와 공유 측면에서 이점을 제공할 수 있습니다.
            - 세그먼트는 세그먼트 테이블을 사용하여 가상 주소를 물리적 주소로 매핑합니다. 각 세그먼트는 시작 주소와 길이를 가집니다.
            - 세그먼트 방식은 외부 단편화 문제에 직면할 수 있지만, 내부 단편화는 발생하지 않습니다.
            

- 자료구조
    - 해시 테이블 작동원리
        - 키를 해시 함수를 통해 해시값으로 변환하고, 이 해시값을 인덱스로 사용하여 데이터를 배열 같은 데이터 구조에 저장함.
        - 이 과정에서 해시 함수가 중요한 역할을 하는데, 이 함수는 키를 고르게 분포된 해시값으로 매핑하여 테이블 내에서의 데이터 저장과 검색을 효율적으로 만듬
    - 해시 충돌이 무엇이며 처리방법
        - 해시 충돌은 두개 이상의 키가 같은 해시값을 가지게 되어, 동일한 위치에 저장되어야 하는 상황을 말함
        - 해시 테이블의 성능을 유지하기 위해 충돌을 효과적으로 관리하는 것이 중요
        - 해시 충돌 처리방법
            - 체이닝
                - 충돌이 발생한 모든 요소를 연결리스트로 만들어 동일한 해시 버킷에 저장하고 검색, 삽입, 삭제 연산 시 해당 리스트를 순회하여 원하는 값을 찾음
            - 오픈 어드레싱
                - 충돌이 발생하는 경우 다른 해시 버킷에 해당 요소를 저장함
                - 이를 위해 선형조사 제곱조사 더블해싱 등의 방법이 사용됨
    - 로드팩터
        - 로드 팩터는 해시 테이블에서 데이터의 저장된 정도를 나타내는 지표로, **`저장된 항목 수 / 버킷 수`**로 계산됩니다. 로드 팩터의 값이 너무 높으면 해시 충돌의 가능성이 증가하여 해시 테이블의 성능이 저하됩니다. 반면, 너무 낮은 경우 메모리를 비효율적으로 사용하게 됩니다. 일반적으로 로드 팩터가 특정 임계값(예: 0.75)을 초과하면 해시 테이블의 크기를 조정(재해싱)하여 성능을 유지

- 알고리즘
    - 퀵소트
        - 분할 정복 전략을 사용하는 정렬 알고리즘
        - 배열을 분할하여 정복하는 것으로 피벗이라고 하는 기준값을 선택한 다음 작은 요소는 피벗의 왼쪽 피벗보다 큰 요소는 피벗의 오른쪽으로 이동시키는 과정 반복하여 배열 정렬
            1. **피벗 선택**: 배열에서 하나의 요소를 피벗으로 선택합니다.
            2. **분할**: 피벗을 기준으로 배열을 두 부분으로 나눕니다. 피벗보다 작은 모든 요소는 피벗의 왼쪽에, 피벗보다 큰 모든 요소는 오른쪽에 오도록 합니다.
            3. **정복**: 분할된 두 부분을 재귀적으로 정렬합니다.
            4. **결합**: 정렬된 부분 배열들을 결합하여 최종적으로 정렬된 배열을 얻습니다. 퀵소트는 실제로 부분 배열들을 물리적으로 결합하지 않으며, 배열이 재귀적으로 정렬됩니다.
        - 시간 복잡도
            - 평균 O(n log n) 퀵소트는 평균적으로 모든 레벨에서 분할이 균등하게 이루어질 떄 가장 효율적
            - 최악 O(n^2) 피벗이 항상 최소값이나 최댓값으로 선택되어 분할이 한쪽으로 치우쳐질때 발생
