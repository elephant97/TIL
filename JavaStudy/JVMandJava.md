# JVM(Java Virtual Merchine), Java 📌

### JDK와 JRE
* JDK(Java Development Kit)
* JRE(Java Runtime Enviroment)
  * 실행만을 위한 환경, 이 JRE만 설치하면 자바를 컴파일 하는 등의 각종 프로그램이 제외된 상태로 설치 됨.
  * 자바를 실행할 수 있는 환경의 집합

### Java언어의 특징
1. 단순하고, 객체지향이며, 친숙 해야한다.
   * 수 많은 프레임워크가 있고, 여러 관련된 사항들을 알아야 프로그램을 작성할 수 있다.
   * 자바의 단순함이란 자바에 대한 기본 컨셉을 배우는 것이 어렵지 않다는 것을 의미함.
   * 객체지향으로 디자인 되어있으며 다형성, 캡슐화 등 객체지향 언어의 특징들을 지원할 수 있는 구조로 되어있음.
   * 자바를 쓴다고 해서 무조건 객체 지향적으로 개발된다는 것은 아님
   * 개발하면서 여러 필요한 기능들은 API를 통해서 제공하고 있음.
2. 견고하며, 보안상 안전하다.
   * 컴파일 할 떄와 실행할 때 문법적 오류에 대한 체크를 함.
   * 메모리 관리 모델이 매우 단순함.
   * 이러한 특징들이 매우 믿을 수 있고 견고한 소프트웨어가 될 수 있도록 도와줌
   * 분산환경에서 사용하기 위해서 디자인 되었음.
   * 자바기술은 외부 침입이 불가능한 애플리케이션을 만들 수 있음.
   * 네트워크 환경에서 클라이언트로 다운로드한 승인받지 않은 프로그램은 실행할 수 없도록 되어있다.
   * 바이러스를 생성하거나 파일 시스템을 공격할 수 없음
   * 간혹 JDK 내부의 오류나 라이브러리 오류로 인해 보안취약점이 발견되기도 함.
3. 아키텍처에 중립적이어야 하며 포터블 해야함
   * 다양한 하드웨어 아키텍처에서 수행할 수 있도록 되어있다.
   * 아키텍처에 중립적인 바이트코드를 생성함.
   * 자바의 버전만 동일하다면, 동일한 프로그램은 어떤 플랫폼에서도 실행할 수 있다.
   * 호환성과 포터블한 환경을 제공할 수 있는 것은 JVM 때문임
4. 높은 성능을 제공해야 함
   * 자동화된 가비지 컬렉터는 낮은 순위의 쓰레드로 동작하기 때문에 높은 성능을 낼 수 있음.
   * 빠른 성능을 위해 네이티브한 언어로 작성한 부분을 자바에서 사용할 수도 있도록 되어있음.
5. 인터프리트 언어이며, 쓰레드를 제공하고, 동적인 언어이다.
   * 인터프리터는 자바 바이트 코드를 어떤 장비에서도 수행할 수 있도록 함.
   * 빠른환경을 구축할 수 있음.
   * 멀티 쓰레드를 환경을 제공하기 때문에 동시에 여러 작업을 수행할 수 있음
   * 자바컴파일러는 매우 엄격한 정적인 점검을 수행함
   * 실행시에 동적으로 필요한 프로그램들을 링크시킴 

### 자바 버전 별 차이
* JDK 1.1
  - AWT 이번트 모델의 확장 및 변경
    > AWT : Abstract Window Toolkit, UI를 구성할 떄 사용되는 기반 기술
  - 내부클래스 추가
  - JavaBeans, JDBC, RMI등 추가
    > JavaBeans : 자바에서 제공하는 컴포넌트 모델 중 하나
    > JDBC : Java Database Connectivity
    > RMI : Remote Method Invocation, 같은 JVM에 있는 메소드를 호출하는 것이 아니라 원격 JVM에 있는 메소드를 호출하기 위한 기술
* JDK 1.2
  - strictfp 예약어 추가
  - 자바에서 GUI를 제공하기 위한 Swing이 코어 라이브러리에 추가
  - JIT라는 컴파일러가 Sun JVM에 처음 추가
    > JIT : Just-In-TIme, 어떤 메소드 일부 혹은 전체 코드를 네이티브 코드로 변환하여 JVM에서 변역하지 않도록 함으로 써 보다 빠른 성능 제공
  - 자바 플러그인 추가
  - CORBA 기술과 데이터를 주고 받기 위한 IDL추가
  - 각종 자료구조를 쉽게 처리하기 위한 Collection 프레임 워크 추가
* JDK 1.3
  - HotSpot JVM 추가
  - CORBBA와의 호환성을 위해 RMI 수정
  - 자바에서 사운드를 처리하기 위한 JavaSound 라이브러리 추가
  - JNDI(Java Naming and Directory Interface)가 코어 라이브러리에 추가
    > 어떤 객체를 쉽게 찾을 수 있도록 도와주는 이름을 지정한 후, 나중에 그 이름으로 객체를 찾아가는 것
  - 자바의 디버깅을 보다 쉽게 하기 위한 JPDA(Java Platform Debugger Architecture)추가
  - Synthetic 프록시 클래스 추가
* JDK 1.4
  - assert 예약어 추가
  - Perl 언어의 정규표현식을 따르는 **정규표현식** 추가
    > 이메일의 주소의 조건에 맞는지, 웹 페이지의 주소를 나타내는 URL 조건에 맞는지 등을 확인하는데 사용
  - exception chaining이라는 것을 통하여 하이 레벨의 예외의 캡슐화가 가능해짐
  - IPv6 지원 시작
  - **NIO**(New Input/Output)라는 non-blocking 추가
    > 기존 IO처리보다 빠르고, 성능이 비교할 수 없을 정도로 빠름
  - 각종 로그 처리 위한 logging API 추가
  - JPEG이나 PNG같은 이미지를 읽고 쓰기 위한 image I/O API 추가
  - 통합 XML 파서와 JAXP라는 XSLT프로세서 추가
  - JCE, JSSE, JAAS와 같은 통합 보안 및 cryptography extensions추가
  - Java Web Start추가
  - 각종 설정 값들을 읽고 저장하는데 사용되는 Preference API(Java.util.prefs)추가
* Java 5
  - 안전하게 컬렉션 데이터를 처리할 수 있는 **제네릭** 추가
  - **어노테이션** 이라고 불리는 **메타데이터** 추가
  - 기본 자료형과 그 기본 자료형을 객체로 다루는 클래스 간의 데이터 변환이 자동으로 발생하는 **autoboxing 및 unboxing** 추가
  - 상수타입을 나타내는 **enum** 추가
  - 매개 변수를 가변적으로 선언할 수 있는 **varargs** 추가
  - for loop를 콜론으로 구분하여 배열이나 컬랙션 타입에 저장되어 있는 데이터를 순차적으로 꺼내는 향상된 for루프 추가
  - import 앞에 static을 붙여 정적 import가 가능하도록 해주는 **static import** 추가
  - 쓰레드 처리를 쉽게 할 수 있는 concurrent 패키지 추가
  - 스트림이나 버퍼로 들어오는 데이터 분석(parse)을 보다 간편하게 할 수 있는 **Scanner 클래스** 추가
* Java 6
  - 스크립팅 언어가 JVM 위에서 수행 가능하게 됨
  - 각종 코어 기능의 성능 개선
  - Compiler API가 추가되어 프로그램에서 자바 컴파일러 실행 가능
* [Java 7]()
* [Java 8]()
  - **람다(lambda)** 표현식 가능

### 컴퓨터 프로그램을 실행시키는 방식
* 인터프리트 방식
  - 프로그램을 실행할 때 마다 컴퓨터가 알아들을 수 있는 언어로 변환하는 작업을 수행
  - 간편하기는 하나, 성능이 매우 느림
* 정적(static) 컴파일 방식
 - 실행하기 전에 컴퓨터가 알아 들을 수 있는 언어로 변환하는 작업을 미리 실행함
   
### JIT 컴파일러란?
 > JIT: Just-In-Time의 약자
 > 좀더 쉬운 말로 하자면 "동적변환 dynamic translavtion"
 > 프로그램 실행을 좀더 빠르게 하기 위해 만들어 졌으며, 명칭이 컴파일러이지만 실행시에 적용되는 기술이다.
  * JIT는 정적 컴파일 방식과 인터프리트 방식을 혼합한 것
  * 변환 작업은 인터프리터에 의해서 지속적으로 수행되지만, 필요한 코드의 정보는 캐싱에 담아두었다가(메모리에 올려두었다가)재 사용하게 됨.
  * javac 라는 명령어를 이용하여 컴파일을 하는 단계에서 만들어진 class 라는 파일은 **바이트코드**임
  * 한번 컴파일한 코드로 리눅스, 맥, 윈도우 등에서 모두 사용할 수 있음
  * javac 명령어를 수행한다는 것은 텍스트로 만든 java 파일을 어떤 OS에서도 수행될 수 있도록 바이트코드 라는 파일로 만든 것
  * 이 바이트 코드를 JIT컴파일러에서 함(JVM -> 기계코드)
  * **장점: JIT를 사용하면 반복적으로 수행되는 코드는 매우 빠른 성능을 보인다**
  * **단점: 처음에 시작할 때에는 변환 단계를 거처야 하므로 성능이 느림**

### HOTSPOT
> Java에서는 HotSpot 클라이언트 컴파일러와 HotSpot 서버 컴파일러 두가지 컴파일러를 제공함
> JDK 1.3전에 나왔던 가상머신과 구분하기 위해 이름을 HotSpot으로 지정함
> 클라이언트 컴파일러와 서버 컴파일러는 자바가 시작할 때 기본적으로 클라이언트 장비인지 서버 장비인지 확인함
> 2개 이상의 물리적 프로세서, 2GB 이상의 물리적 메모리이면 JVM은 서버 컴파일러를 선택함
> 윈도우는 기본적으로 지정해주지 않으면 클라이언트 컴파일러가 사용 됨
* HotSpot 클라이언트 컴파일러
  > 명시적으로 지정하는 법
  > java -server -Xms512 excode (여기에서 -Xms는 JVM 시작 메모리 크기를 지정하는 것)
  
  * CPU 코어가 하나뿐인 사용자를 위해 만들어 진 것이다.
  * 애플리케이션 시작 시간을 빠르게 하고, 적은 메모리 점유하도록 하는 것이 주요 특징
* HotSpot 서버 컴파일러
  * 코어가 많은 장비에서 애플리케이션을 돌리기 위해 만들어진 것
  * 애플리케이션 수행 속도에 초점이 맞추어져 있음

### JVM (Java Virtual Machine) 자바 가상 머신
 > 자바 프로그램이 수행되는 프로세스를 의미함.
 > java라는 명령어를 통해 어플리케이션이 실행되면, 이 JVM 위에서 어플리케이션이 동작함.
 > JVM내에서 메모리 관리를 알아서 함(GC)

### GC(Garbege Collecter)
> JVM내에서 메모리 관리를 해주는 것   
> 사용하고 남아있는 전혀 필요 없는 객체들이 여기에 속한다.   
> Java 7부터 공식적으로 사용할 수 있는 G1(Garbege First)라는 가비지 컬렉터를 제외한 나머지 JVM은 힙이라는 공간에 객체를 관리함.

### Java의 Heap 영역
> 크게는 Young 영역, Old 영역, Perm 영역 3가지 영역으로 나뉜다.
* Young 영역
  * 젊은 객체들이 존재
  * Eden영역과 두 개의 Survior 영역으로 나뉨
  * 객체를 생성하자마자 저장되는 장소는 Eden 영역임

### Minor GC와 Full GC
* Minor GC(마이너 GC 혹은 Young GC)의 동작
  * Eden 영역에서 객체가 생성되는데, Eden 영역이 가득 차게 되면 살아있는 객체만 Survior로 복사함
  * 위의 과정이 반복되면서, Survior 영역 역시 가득 차게 되었을 때 또 다른 Survior 영역으로 객체 복사가 일어남
  * 즉 Survior 영역의 둘 중 하나는 반드시 비어있어야만 함.
  * 마이너 GC에서는 copy 알고리즘을 통해 객체를 처리함
  * Full GC 보다 더 작은 공간이 할당되기 때문에 더 빠름
* Full GC(풀 GC 혹은 메이저 GC)
  * 마이너 GC가 발생 되다가, 오래 살아있는 객체들은 OLD영역으로 이동함
  * 지속적으로 이동하다가 Old 영역이 꽉 차게 되는 경우 Full GC가 발생함
  * 풀 GC는 전체 힙 영역을 검사하여 쓰레기 객체를 식별하고 수집
  * 주로 "Mark and Sweep" 또는 "Mark and Compact" 알고리즘이 사용됨
    
  ### Oracle JDK에서 제공하는 GC의 방식
  * Serial GC
     > Was에서 사용하는 JVM에서 사용하면 안됨.   
     > 이 GC방식은  -client 옵션을 지정했을 때 사용 됨
     > Clinet용 장비에 최적화 된 GC이기 때문에 WAS에서 이 방식을 사용하면 GC 속도가 매우 느려 웹 애플리케이션이 엄청 느려짐
  * Parallel Young Generation Collector
  * Parallel Old Generation Collector
  * Concourrenct Mark & Sweep Collector (CMS)
  * Shenandoah GC
  * ZGC
